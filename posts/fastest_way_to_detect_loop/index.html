<!doctype html><html lang=en-us><head><title>Fastest way to detect loop in a linked list // Vaibhav's Blogs</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.117.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Christopher Hart"><meta name=description content><link rel=stylesheet href=/blog/css/main.min.3c3c186cd62e563ad6e2f00a89dbee656ab912d1d46f856b5605dd0232521e2a.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Fastest way to detect loop in a linked list"><meta name=twitter:description content="Fastest way to detect loop in a linked list Linked lists, a fundamental data structure, often come with their share of challenges. One of these challenges is detecting a loop within them. Over the years, many algorithms have been devised to address this issue, from Floyd&rsquo;s Cycle Detection algorithm (also known as the &ldquo;Tortoise and the Hare&rdquo; algorithm) to various hashing techniques. Today, we&rsquo;re exploring a novel approach rooted in the mechanics of memory allocation."><meta property="og:title" content="Fastest way to detect loop in a linked list"><meta property="og:description" content="Fastest way to detect loop in a linked list Linked lists, a fundamental data structure, often come with their share of challenges. One of these challenges is detecting a loop within them. Over the years, many algorithms have been devised to address this issue, from Floyd&rsquo;s Cycle Detection algorithm (also known as the &ldquo;Tortoise and the Hare&rdquo; algorithm) to various hashing techniques. Today, we&rsquo;re exploring a novel approach rooted in the mechanics of memory allocation."><meta property="og:type" content="article"><meta property="og:url" content="https://Vaibhav-sarvashreshth.github.io/blog/posts/fastest_way_to_detect_loop/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-16T15:10:44+05:30"><meta property="article:modified_time" content="2023-07-16T15:10:44+05:30"></head><body><header class=app-header><a href=https://Vaibhav-sarvashreshth.github.io/blog/><img class=app-header-avatar src=/blog/avatar.jpg alt="Christopher Hart"></a>
<span class=app-header-title>Vaibhav's Blogs</span><nav class=app-header-menu><a class=app-header-menu-item href=/blog/tags/>Tags</a></nav><p>A blog about all things technical.</p><div class=app-header-social><a href=https://github.com/Vaibhav-sarvashreshth target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://github.com/Vaibhav-sarvashreshth target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Fastest way to detect loop in a linked list</h1><div class=post-meta><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Jul 16, 2023</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>3 min read</div></div></header><div class=post-content><h1 id=fastest-way-to-detect-loop-in-a-linked-list><strong>Fastest way to detect loop in a linked list</strong></h1><p>Linked lists, a fundamental data structure, often come with their share of challenges. One of these challenges is detecting a loop within them. Over the years, many algorithms have been devised to address this issue, from Floyd&rsquo;s Cycle Detection algorithm (also known as the &ldquo;Tortoise and the Hare&rdquo; algorithm) to various hashing techniques. Today, we&rsquo;re exploring a novel approach rooted in the mechanics of memory allocation.</p><h2 id=intuition-behind-the-approach><strong>Intuition Behind the Approach</strong></h2><p>The foundation of this method is built upon a key observation regarding dynamic memory allocation. In many systems:</p><ol><li>Linked lists are allocated dynamically, meaning they reside in the heap memory.</li><li>The heap grows from bottom to top, allocating memory addresses from low to high.</li></ol><p><img src=https://courses.engr.illinois.edu/cs225/fa2022/assets/notes/stack_heap_memory/memory_layout.png alt="Heap picture"></p><ol start=3><li>Thus, if the linked list is progressing normally (without loops), subsequent nodes should have progressively higher memory addresses than their predecessors.</li></ol><p>Leveraging this observation, the method postulates: if a later node in the linked list has a memory address lower than its predecessor, a loop is present.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Definition for singly-linked list.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * struct ListNode {
</span></span></span><span style=display:flex><span><span style=color:#75715e> *     int val;
</span></span></span><span style=display:flex><span><span style=color:#75715e> *     ListNode *next;
</span></span></span><span style=display:flex><span><span style=color:#75715e> *     ListNode(int x) : val(x), next(NULL) {}
</span></span></span><span style=display:flex><span><span style=color:#75715e> * };
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> hasCycle(ListNode <span style=color:#f92672>*</span>head)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(head<span style=color:#f92672>!=</span>NULL <span style=color:#f92672>&amp;&amp;</span> head <span style=color:#f92672>&lt;</span> head<span style=color:#f92672>-&gt;</span>next)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            head <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }     
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> head <span style=color:#f92672>&amp;&amp;</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>The code is refreshingly simple. As it traverses the linked list, it constantly checks if the memory address of the current node (head) is less than that of the next node (head->next). If ever it encounters a node with a higher address pointing to a node with a lower address, it suggests the presence of a loop and breaks from the traversal.</p><h2 id=considerations-and-limitations><strong>Considerations and Limitations</strong></h2><p>While this approach is innovative and takes advantage of underlying memory mechanics, it&rsquo;s essential to consider a few points:</p><ol><li><p><strong>Memory Allocation Behavior</strong>: The behavior of memory allocation can differ based on the system and compiler. Not all systems guarantee the observed heap allocation pattern from low to high addresses.</p></li><li><p><strong>Memory Reuse</strong>: Modern memory allocators might reuse freed blocks of memory, which could lead to cases where the assumption about memory addresses doesn&rsquo;t hold.</p></li><li><p><strong>Alternative Techniques</strong>: Traditional methods like Floyd&rsquo;s Cycle Detection are universal and don&rsquo;t rely on system-specific behaviors.</p></li></ol><h2 id=wrapping-up><strong>Wrapping Up</strong></h2><p>The beauty of computer science lies in the diversity of solutions to a given problem. This novel approach to loop detection in linked lists offers a fresh perspective, rooted in the intricacies of memory. While it&rsquo;s essential to be cautious of its limitations, the method stands as a testament to the innovative spirit of problem-solving in the realm of algorithms and data structures.</p></div><div class=post-footer></div></article></main></body></html>