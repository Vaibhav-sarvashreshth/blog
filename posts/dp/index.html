<!doctype html><html lang=en-us><head><title>Top 50 DP Questions // Vaibhav's Blogs</title>
<link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.120.4"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Christopher Hart"><meta name=description content><link rel=stylesheet href=/blog/css/main.min.3c3c186cd62e563ad6e2f00a89dbee656ab912d1d46f856b5605dd0232521e2a.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Top 50 DP Questions"><meta name=twitter:description content="List Of Questions: Subset Sum Problem Longest Common Subsequence Longest Increasing Subsequence Edit Distance Longest Path In Matrix Optimal Strategy for a Game 0-1 Knapsack Problem Shortest Common Supersequence Partition problem Rod Cutting Coin change problem Word Break Problem Dice Throw Problem Box Stacking Egg Dropping Puzzle Max length chain Longest Common Substring Interleaved strings Maximum sum increasing subsequence Minimum number of jumps Count subsequences of type a^i, b^j, c^k Get Minimum Squares Nth Fibonacci Number Longest Palindromic Substring Total Decoding Messages Unique BST’s Player with max score Form a palindrome Word Wrap Problem Count Palindromic Subsequences Minimum time to finish tasks without skipping two consecutive Minimum Partition Boolean Parenthesization Problem Matrix Chain Multiplication Subset Sum Problem Given an array of non-negative integers, and a value sum, determine if there is a subset of the given set with sum equal to given sum."><meta property="og:title" content="Top 50 DP Questions"><meta property="og:description" content="List Of Questions: Subset Sum Problem Longest Common Subsequence Longest Increasing Subsequence Edit Distance Longest Path In Matrix Optimal Strategy for a Game 0-1 Knapsack Problem Shortest Common Supersequence Partition problem Rod Cutting Coin change problem Word Break Problem Dice Throw Problem Box Stacking Egg Dropping Puzzle Max length chain Longest Common Substring Interleaved strings Maximum sum increasing subsequence Minimum number of jumps Count subsequences of type a^i, b^j, c^k Get Minimum Squares Nth Fibonacci Number Longest Palindromic Substring Total Decoding Messages Unique BST’s Player with max score Form a palindrome Word Wrap Problem Count Palindromic Subsequences Minimum time to finish tasks without skipping two consecutive Minimum Partition Boolean Parenthesization Problem Matrix Chain Multiplication Subset Sum Problem Given an array of non-negative integers, and a value sum, determine if there is a subset of the given set with sum equal to given sum."><meta property="og:type" content="article"><meta property="og:url" content="https://Vaibhav-sarvashreshth.github.io/blog/posts/dp/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-18T15:10:44+05:30"><meta property="article:modified_time" content="2023-07-18T15:10:44+05:30"></head><body><header class=app-header><a href=https://Vaibhav-sarvashreshth.github.io/blog/><img class=app-header-avatar src=/blog/avatar.jpg alt="Christopher Hart"></a>
<span class=app-header-title>Vaibhav's Blogs</span><nav class=app-header-menu><a class=app-header-menu-item href=/blog/tags/>Tags</a></nav><p>A blog about all things technical.</p><div class=app-header-social><a href=https://github.com/Vaibhav-sarvashreshth target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://github.com/Vaibhav-sarvashreshth target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Top 50 DP Questions</h1><div class=post-meta><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Jul 18, 2023</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>24 min read</div></div></header><div class=post-content><h2 id=list-of-questions>List Of Questions:</h2><ol><li><a href=#subset-sum-problem>Subset Sum Problem</a></li><li><a href=#longest-common-subsequence>Longest Common Subsequence</a></li><li><a href=#longest-increasing-subsequence>Longest Increasing Subsequence</a></li><li><a href=#edit-distance>Edit Distance</a></li><li><a href=#longest-path-in-matrix>Longest Path In Matrix</a></li><li><a href=#optimal-strategy-for-a-game>Optimal Strategy for a Game</a></li><li><a href=#0-1-knapsack-problem>0-1 Knapsack Problem</a></li><li><a href=#shortest-common-supersequence>Shortest Common Supersequence</a></li><li><a href=#partition-problem>Partition problem</a></li><li><a href=#rod-cutting>Rod Cutting</a></li><li><a href=#coin-change-problem>Coin change problem</a></li><li><a href=#word-break-problem>Word Break Problem</a></li><li><a href=#dice-throw-problem>Dice Throw Problem</a></li><li><a href=#box-stacking>Box Stacking</a></li><li><a href=#egg-dropping-puzzle>Egg Dropping Puzzle</a></li><li><a href=#max-length-chain>Max length chain</a></li><li><a href=#longest-common-substring>Longest Common Substring</a></li><li><a href=#interleaved-strings>Interleaved strings</a></li><li><a href=#maximum-sum-increasing-subsequence>Maximum sum increasing subsequence</a></li><li><a href=#minimum-number-of-jumps>Minimum number of jumps</a></li><li><a href=#count-subsequences-of-type-a%5Ei-b%5Ej-c%5Ek>Count subsequences of type a^i, b^j, c^k</a></li><li><a href=#get-minimum-squares>Get Minimum Squares</a></li><li><a href=#nth-fibonacci-number>Nth Fibonacci Number</a></li><li><a href=#longest-palindromic-substring>Longest Palindromic Substring</a></li><li><a href=#total-decoding-messages>Total Decoding Messages</a></li><li><a href=#unique-bst%E2%80%99s>Unique BST’s</a></li><li><a href=#player-with-max-score>Player with max score</a></li><li><a href=#form-a-palindrome>Form a palindrome</a></li><li><a href=#word-wrap-problem>Word Wrap Problem</a></li><li><a href=#count-palindromic-subsequences>Count Palindromic Subsequences</a></li><li><a href=#minimum-time-to-finish-tasks-without-skipping-two-consecutive>Minimum time to finish tasks without skipping two consecutive</a></li><li><a href=#minimum-partition>Minimum Partition</a></li><li><a href=#boolean-parenthesization-problem>Boolean Parenthesization Problem</a></li><li><a href=#matrix-chain-multiplication>Matrix Chain Multiplication</a></li></ol><h2 id=subset-sum-problem><strong>Subset Sum Problem</strong></h2><p>Given an array of non-negative integers, and a value sum, determine if there is a subset of the given set with sum equal to given sum.</p><p>Example 1:</p><p>Input:
N = 6
arr[] = {3, 34, 4, 12, 5, 2}
sum = 9
Output: 1
Explanation: Here there exists a subset with
sum = 9, 4+3+2 = 9.</p><h2 id=solution>Solution</h2><p>This problem is similar to Knapsack Problem.</p><h3 id=code-c>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isSubsetSum</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>arr, <span style=color:#66d9ef>int</span> sum)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>int</span> n<span style=color:#f92672>=</span>arr.size();
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>bool</span> t[n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>][sum<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>=</span>{true};
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       <span style=color:#75715e>// make first row as false, as with empty sack you cant make any sum (except 0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;j<span style=color:#f92672>&lt;=</span>sum;j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>       {
</span></span><span style=display:flex><span>            t[<span style=color:#ae81ff>0</span>][j]<span style=color:#f92672>=</span>false;
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;i<span style=color:#f92672>&lt;=</span>n;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>       {
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;j<span style=color:#f92672>&lt;=</span>sum;j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(arr[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>&lt;=</span>j)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// this is just derived from knapsack as here also we are filling knapsack 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// such that our sum is maximum 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    t[i][j] <span style=color:#f92672>=</span> t[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j]<span style=color:#f92672>||</span>t[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j<span style=color:#f92672>-</span>arr[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]];
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    t[i][j]<span style=color:#f92672>=</span>t[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j];
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>               
</span></span><span style=display:flex><span>           }
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>return</span> t[n][sum];
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>   
</span></span></code></pre></div><h2 id=longest-common-subsequence><strong>Longest Common Subsequence</strong></h2><p>Given two strings, find the length of longest subsequence present in both of them. Both the strings are in uppercase latin alphabets.</p><p>Example 1:</p><p>Input:
A = 6, B = 6
str1 = ABCDGH
str2 = AEDFHR
Output: 3
Explanation: LCS for input strings “ABCDGH” and “AEDFHR” is “ADH” of length 3.</p><h2 id=solution-1>Solution</h2><h3 id=code-c-1>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lcs</span>(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y, string s1, string s2)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// your code here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>dp(x<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(y<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;i<span style=color:#f92672>&lt;=</span>x;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;j<span style=color:#f92672>&lt;=</span>y;j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(s1[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>==</span>s2[j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    dp[i][j] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> dp[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    dp[i][j] <span style=color:#f92672>=</span> max(dp[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j],dp[i][j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dp[x][y];
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=longest-increasing-subsequence><strong>Longest Increasing Subsequence</strong></h2><p>Given an array of integers, find the length of the longest (strictly) increasing subsequence from the given array.</p><p>Example 1:</p><p>Input:
N = 16
A = {0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15}
Output:
6
Explanation:
There are more than one LIS in this array. One such Longest increasing subsequence is {0,2,6,9,13,15}.</p><h2 id=solution-2>Solution</h2><p>Dynamic Programming Approach :
This approach will work in O(n^2) time, where n is the length of the input array.</p><pre><code>In this method, we'll maintain a dp[] array such that dp[i] contains the length of the longest increasing subsequence ending with arr[i].

For every i from 0 to n-1, we'll find the longest increasing subsequence ending with arr[i] by checking all elements before i and keeping track of the maximum length.
</code></pre><h3 id=code-c-2>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>longestSubsequence</span>(<span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> a[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dp(n, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> i; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (a[i] <span style=color:#f92672>&gt;</span> a[j]) {
</span></span><span style=display:flex><span>                dp[i] <span style=color:#f92672>=</span> max(dp[i], dp[j] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span>max_element(dp.begin(), dp.end());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><h2 id=solution-3>Solution</h2><p>Binary Search Approach :</p><pre><code>The Binary Search approach works in O(n log n) time. In this method, we'll maintain an array tail[] such that tail[i-1] stores the smallest possible tail element for all increasing subsequences of length i.
</code></pre><h3 id=code-c-3>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>longestSubsequence</span>(<span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> a[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> tail(n, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> length <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// length of longest increasing subsequence
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    tail[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> a[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (a[i] <span style=color:#f92672>&gt;</span> tail[length<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>            tail[length<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> a[i];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> lower_bound(tail.begin(), tail.begin()<span style=color:#f92672>+</span>length, a[i]);
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>it <span style=color:#f92672>=</span> a[i];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> length;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><p>Here, for each element in the input, if it is greater than the current longest subsequence&rsquo;s tail, it is appended in the tail, else it is used to replace the next greater element (found using binary search) in tail[]. The final length of tail[] is the length of the longest increasing subsequence.</p><h2 id=edit-distance><strong>Edit Distance</strong></h2><p>Given two strings s and t. Return the minimum number of operations required to convert s to t.
The possible operations are permitted:</p><pre><code>Insert a character at any position of the string.
Remove any character from the string.
Replace any character from the string with any other character.
</code></pre><p>Input:
s = &ldquo;geek&rdquo;, t = &ldquo;gesek&rdquo;
Output: 1
Explanation: One operation is required
inserting &rsquo;s&rsquo; between two &rsquo;e&rsquo;s of s.</p><h2 id=solution-4>Solution</h2><p>We will be using a 2D DP table where dp[i][j] represents the minimum number of operations to convert s up to i into t up to j.</p><h3 id=code-c-4>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>editDistance</span>(string s, string t)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// get the length of the strings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> s.length();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> t.length();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// create a DP table of size (n+1) x (m+1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> dp(n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(m<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// initialize the DP table
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;=</span>n; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; j<span style=color:#f92672>&lt;=</span>m; j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#75715e>// if string s is empty, insert all characters of t into s
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span>(i<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>) dp[i][j] <span style=color:#f92672>=</span> j;
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#75715e>// if string t is empty, remove all characters of s
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(j<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>) dp[i][j] <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#75715e>// if the last characters are same, get result for remaining strings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(s[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> t[j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]) dp[i][j] <span style=color:#f92672>=</span> dp[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#75715e>// if the last characters are different, consider all operations
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    dp[i][j] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> min({ dp[i][j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>],     <span style=color:#75715e>// insert
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                        dp[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j],     <span style=color:#75715e>// remove
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                        dp[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] }); <span style=color:#75715e>// replace
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// return the final result
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> dp[n][m];
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>In this code, we first initialize the DP table such that dp[i][0] = i and dp[0][j] = j. Then for each pair of characters in the two strings, we either get the result for the remaining strings if the characters are same, or consider all three operations and choose the one with minimum cost if the characters are different. The final result is dp[n][m].</p><h2 id=longest-path-in-a-matrix><strong>Longest Path in a matrix</strong></h2><p>Given a n*m matrix, find the maximum length path (starting from any cell) such that all cells along the path are in strictly increasing order.</p><p>We can move in 4 directions from a given cell (i, j), i.e., we can move to (i+1, j) or (i, j+1) or (i-1, j) or (i, j-1).
Input: matrix = {{1,2,9},{5,3,8},{4,6,7}}
Output: 7
Explanation: The longest increasing path is
{1,2,3,6,7,8,9}.</p><h2 id=solution-5>Solution</h2><p>We will keep a memo table to store the length of longest path starting from each cell. If this value is already computed, we will return it instead of recomputing it.</p><h3 id=code-c-5>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Direction vectors
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> dx[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> dy[] <span style=color:#f92672>=</span> {<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// DFS function to compute the longest path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dfs</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> matrix, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j, vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> dp) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If this subproblem has already been solved, return the answer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(dp[i][j] <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> dp[i][j];
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> matrix.size(), n <span style=color:#f92672>=</span> matrix[<span style=color:#ae81ff>0</span>].size();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Check all 4 directions
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; k <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>; k<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> dx[k], y <span style=color:#f92672>=</span> j <span style=color:#f92672>+</span> dy[k];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(x <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> x <span style=color:#f92672>&lt;</span> m <span style=color:#f92672>&amp;&amp;</span> y <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> y <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>&amp;&amp;</span> matrix[x][y] <span style=color:#f92672>&gt;</span> matrix[i][j])
</span></span><span style=display:flex><span>            dp[i][j] <span style=color:#f92672>=</span> max(dp[i][j], dfs(matrix, x, y, dp));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Include the current cell in the path and return
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>++</span>dp[i][j];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>longestIncreasingPath</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> matrix) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(matrix.empty()) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> matrix.size(), n <span style=color:#f92672>=</span> matrix[<span style=color:#ae81ff>0</span>].size(), ans <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> dp(m, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(n, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> m; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> n; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            ans <span style=color:#f92672>=</span> max(ans, dfs(matrix, i, j, dp));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><p>This code first initializes a DP table of the same size as the input matrix, with all elements set to 0. It then computes the longest increasing path starting from each cell using a DFS function, and stores the results in the DP table. The maximum value in the DP table is the length of the longest increasing path.</p><h2 id=optimal-strategy-for-a-game><strong>Optimal Strategy For A Game</strong></h2><p>You are given an array A of size N. The array contains integers and is of even length. The elements of the array represent N coin of values V1, V2, &mldr;.Vn. You play against an opponent in an alternating way.</p><p>In each turn, a player selects either the first or last coin from the row, removes it from the row permanently, and receives the value of the coin.</p><p>You need to determine the maximum possible amount of money you can win if you go first.
Note: Both the players are playing optimally.</p><h2 id=solution-6>Solution</h2><h3 id=code-c-6>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>maximumAmount</span>(<span style=color:#66d9ef>int</span> arr[], <span style=color:#66d9ef>int</span> n)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;&gt;</span> dp(n, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span>(n, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Fill the dp table diagonally
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> gap <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; gap <span style=color:#f92672>&lt;</span> n; gap<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, j <span style=color:#f92672>=</span> gap; j <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>, j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If only one element left, select it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> j)
</span></span><span style=display:flex><span>                    dp[i][j] <span style=color:#f92672>=</span> arr[i];
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If two elements left, select the maximum one
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>==</span> j)
</span></span><span style=display:flex><span>                    dp[i][j] <span style=color:#f92672>=</span> max(arr[i], arr[j]);
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If more than two elements left, select the maximum value after considering the opponent&#39;s move
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    dp[i][j] <span style=color:#f92672>=</span> max(arr[i] <span style=color:#f92672>+</span> min(dp[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>][j], dp[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]),
</span></span><span style=display:flex><span>                                arr[j] <span style=color:#f92672>+</span> min(dp[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>], dp[i][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>]));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dp[<span style=color:#ae81ff>0</span>][n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>In the above code, we create a table dp where an entry dp[i][j] stores the maximum possible value that can be obtained by the player when coins from i to j are left in the game. The base cases are dp[i][j] = arr[i] when only one coin is left and dp[i][j] = max(arr[i], arr[j]) when only two coins are left. For other cases, we consider two scenarios: when the player picks the i&rsquo;th coin or the j&rsquo;th coin. In both cases, the opponent plays optimally and makes the player pick minimum of the values from the remaining coins.</p><h2 id=0---1-knapsack-problem><strong>0 - 1 Knapsack Problem</strong></h2><p>You are given weights and values of N items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack. Note that we have only one quantity of each item.
In other words, given two integer arrays val[0..N-1] and wt[0..N-1] which represent values and weights associated with N items respectively. Also given an integer W which represents knapsack capacity, find out the maximum value subset of val[] such that sum of the weights of this subset is smaller than or equal to W. You cannot break an item, either pick the complete item or dont pick it (0-1 property).</p><h2 id=solution-7>Solution</h2><h3 id=code-c-7>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>knapSack</span>(<span style=color:#66d9ef>int</span> W, <span style=color:#66d9ef>int</span> wt[], <span style=color:#66d9ef>int</span> val[], <span style=color:#66d9ef>int</span> n) 
</span></span><span style=display:flex><span>    { 
</span></span><span style=display:flex><span>       <span style=color:#75715e>// Declaring and Initialising the dp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>dp(n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(W<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;i<span style=color:#f92672>&lt;=</span>n;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>       {
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;j<span style=color:#f92672>&lt;=</span>W;j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>           {
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>if</span>(wt[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>&lt;=</span>j)
</span></span><span style=display:flex><span>               {
</span></span><span style=display:flex><span>                   dp[i][j] <span style=color:#f92672>=</span> max(dp[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j],val[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>+</span>dp[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j<span style=color:#f92672>-</span>wt[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]]);
</span></span><span style=display:flex><span>               }
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>               {
</span></span><span style=display:flex><span>                   dp[i][j] <span style=color:#f92672>=</span> dp[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j];
</span></span><span style=display:flex><span>               }
</span></span><span style=display:flex><span>           }
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>return</span> dp[n][W];
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><h2 id=shortest-common-supersequence><strong>Shortest Common Supersequence</strong></h2><p>Given two strings X and Y of lengths m and n respectively, find the length of the smallest string which has both, X and Y as its sub-sequences.
Note: X and Y can have both uppercase and lowercase letters.</p><p>Example 1</p><p>Input:
X = abcd, Y = xycd
Output: 6
Explanation: Shortest Common Supersequence
would be abxycd which is of length 6 and
has both the strings as its subsequences.</p><p>Example 2</p><p>Input:
X = efgh, Y = jghi
Output: 6
Explanation: Shortest Common Supersequence
would be ejfghi which is of length 6 and
has both the strings as its subsequences.</p><h2 id=solution-8>Solution</h2><p>LCS variation.</p><h3 id=code-c-8>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>shortestCommonSupersequence</span>(string X, string Y, <span style=color:#66d9ef>int</span> m, <span style=color:#66d9ef>int</span> n)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//code here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> m<span style=color:#f92672>+</span>n<span style=color:#f92672>-</span>lcs(X, Y, m, n);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lcs</span>(string s1, string s2, <span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> dp[x<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>][y<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>=</span>{{<span style=color:#ae81ff>0</span>}};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;=</span>x;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            dp[i][<span style=color:#ae81ff>0</span>]<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;j<span style=color:#f92672>&lt;=</span>y;j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            dp[<span style=color:#ae81ff>0</span>][j]<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;i<span style=color:#f92672>&lt;=</span>x;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;j<span style=color:#f92672>&lt;=</span>y;j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(s1[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>==</span>s2[j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    dp[i][j] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> dp[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                 dp[i][j] <span style=color:#f92672>=</span> max(dp[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j],dp[i][j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]);   
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dp[x][y];
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=heading>****</h2><h2 id=solution-9>Solution</h2><p>This problem can be reduced to a subset sum problem. The task is to check if the sum of the array is even. If it&rsquo;s not, then it&rsquo;s not possible to divide the array into two partitions. If the sum is even, then check if there&rsquo;s a subset whose sum is sum/2. If such a subset exists, then we can say the array can be partitioned into two subsets of equal sum.</p><p>Here&rsquo;s a C++ function using dynamic programming to solve the problem:</p><h3 id=code-c-9>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>equalPartition</span>(<span style=color:#66d9ef>int</span> N, <span style=color:#66d9ef>int</span> arr[])
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Calculate the total sum of the array.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> N; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            sum <span style=color:#f92672>+=</span> arr[i];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If the sum is odd, return 0 because it&#39;s impossible to divide the array into two subsets of equal sum.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(sum <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        sum <span style=color:#f92672>/=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Create a DP table, dp[i] will be true if there is a subset of arr[0..j] with sum equal to i.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> dp(sum<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, false);
</span></span><span style=display:flex><span>        dp[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> true; <span style=color:#75715e>// There is always an empty set with sum 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Fill dp table using a modified subset-sum problem approach.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> N; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> sum; j <span style=color:#f92672>&gt;=</span> arr[i]; j<span style=color:#f92672>--</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(dp[j <span style=color:#f92672>-</span> arr[i]])
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    dp[j] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If sum/2 is achievable, return 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(dp[sum]) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>This function calculates the total sum of the array, and checks if it&rsquo;s divisible by 2. If it&rsquo;s not, it returns 0 immediately, because it&rsquo;s impossible to partition the array into two subsets of equal sum. If the sum is even, it then checks if there&rsquo;s a subset whose sum is sum/2 by using a dynamic programming approach. The DP array dp[i] is true if there&rsquo;s a subset of arr[0..j] whose sum is i. The function finally returns whether dp[sum] is true.</p><h2 id=rod-cutting><strong>Rod Cutting</strong></h2><p>Given a rod of length N inches and an array of prices, price[]. price[i] denotes the value of a piece of length i. Determine the maximum value obtainable by cutting up the rod and selling the pieces.</p><p>Note: Consider 1-based indexing.</p><p>Example 1:</p><p>Input:
N = 8
Price[] = {1, 5, 8, 9, 10, 17, 17, 20}
Output:
22
Explanation:
The maximum obtainable value is 22 by
cutting in two pieces of lengths 2 and
6, i.e., 5+17=22.</p><h2 id=solution-10>Solution</h2><p>This problem is the variation of Unbounded Knapsack.</p><h3 id=code-c-10>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>cutRod</span>(<span style=color:#66d9ef>int</span> price[], <span style=color:#66d9ef>int</span> n)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// this problem is identical to un-bounded knapsack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* here we have to replace the weight array with length array
</span></span></span><span style=display:flex><span><span style=color:#75715e>           value array with price array and weight limit with length
</span></span></span><span style=display:flex><span><span style=color:#75715e>           
</span></span></span><span style=display:flex><span><span style=color:#75715e>        */</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> length[n];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>n;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            length[i]<span style=color:#f92672>=</span>(i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> t[n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>][n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        memset(t,<span style=color:#ae81ff>0</span>,<span style=color:#66d9ef>sizeof</span>(t));
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;i<span style=color:#f92672>&lt;=</span>n;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;j<span style=color:#f92672>&lt;=</span>n;j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(length[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>&lt;=</span>j)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    t[i][j]<span style=color:#f92672>=</span>max(t[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j],t[i][j<span style=color:#f92672>-</span>length[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]]<span style=color:#f92672>+</span>price[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    t[i][j]<span style=color:#f92672>=</span>t[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j];
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> t[n][n];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><h2 id=->** **</h2><h2 id=solution-11>Solution</h2><h3 id=code-c-11>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><h2 id=coin-change><strong>Coin Change</strong></h2><p>Given an integer array coins[ ] of size N representing different denominations of currency and an integer sum, find the number of ways you can make sum by using different combinations from coins[ ].<br>Note: Assume that you have an infinite supply of each type of coin. And you can use any coin as many times as you want.</p><p>Example 1:</p><p>Input:
N = 3, sum = 4
coins = {1,2,3}
Output: 4
Explanation: Four Possible ways are: {1,1,1,1},{1,1,2},{2,2},{1,3}.</p><h2 id=solution-12>Solution</h2><p>This problem can be solved using dynamic programming. The idea is to build a table dp where each entry dp[i][j] represents the number of ways to make sum j using the first i types of coins.</p><p>To fill the dp table, we have two choices for each coin at index i (0&lt;=i&lt;N):</p><pre><code>1. We do not use the ith coin: We can just ignore the coin and move on to the next coin, or in other words, we use the value of dp[i-1][j].
2. We use the ith coin: We can use the ith coin and subtract the denomination of the ith coin from j. We then look up this new value in the dp table, dp[i][j-coins[i]].
</code></pre><p>Finally, the answer will be the last entry in the dp table, dp[N][sum].</p><p>Here&rsquo;s a C++ function to solve this problem:</p><h3 id=code-c-12>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>count</span>(<span style=color:#66d9ef>int</span> coins[], <span style=color:#66d9ef>int</span> N, <span style=color:#66d9ef>int</span> sum)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Initialize a dp table with size (N+1) x (sum+1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;&gt;</span> dp(N<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span>(sum<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// When sum is 0, the answer is 1 for all i
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;=</span> N; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        dp[i][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Fill the dp table
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> N; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> sum; j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If the coin value is greater than the current sum j, then we can&#39;t include the coin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (coins[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>&gt;</span> j)
</span></span><span style=display:flex><span>                dp[i][j] <span style=color:#f92672>=</span> dp[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Calculate the number of ways by excluding or including the ith coin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                dp[i][j] <span style=color:#f92672>=</span> dp[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j] <span style=color:#f92672>+</span> dp[i][j<span style=color:#f92672>-</span>coins[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Return the last entry of the dp table
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> dp[N][sum];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><h2 id=word-break><strong>Word Break</strong></h2><p>Given a string A and a dictionary of n words B, find out if A can be segmented into a space-separated sequence of dictionary words.</p><p>Note: From the dictionary B each word can be taken any number of times and in any order.
Example 1:</p><h2 id=solution-13>Solution</h2><h3 id=code-c-13>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#75715e>/*Non DP approach*/</span>
</span></span><span style=display:flex><span>    unordered_map<span style=color:#f92672>&lt;</span>string,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>solve</span>(string s)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>if</span>(s.size()<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>     {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span>     
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;i<span style=color:#f92672>&lt;=</span>s.size(); i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>     {
</span></span><span style=display:flex><span>          string temp <span style=color:#f92672>=</span> (s.substr(<span style=color:#ae81ff>0</span>,i));
</span></span><span style=display:flex><span>          
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span>(m[temp]<span style=color:#f92672>&gt;</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> solve(s.substr(i,s.size()<span style=color:#f92672>-</span>i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)))
</span></span><span style=display:flex><span>          {
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>          }<span style=color:#66d9ef>else</span> <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>wordBreak</span>(string A, vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>B)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>B.size(); i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>         {
</span></span><span style=display:flex><span>          m[B[i]]<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>             
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> solve(A);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=solution-14>Solution</h2><p>DP approach
The idea is to process the given string from the left, one character at a time, while maintaining a boolean array dp[]. An entry dp[i] is true if a valid word (word is in dictionary) ends there. The optimization is to look for a sub-string ending at the current character and also a prefix substring appears in the dictionary.</p><h3 id=code-c-14>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>wordBreak</span>(string A, vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;&amp;</span> B) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> size <span style=color:#f92672>=</span> A.size();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create the DP table to store results of subproblems
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> dp(size<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,false);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Insert all words of dictionary into a trie
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    unordered_set<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> dict;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> B.size(); i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        dict.insert(B[i]);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// iterate over the length of the string
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; i<span style=color:#f92672>&lt;=</span>size; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        <span style=color:#75715e>// if dp[i] is false, then check if it can be segmented
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (dp[i] <span style=color:#f92672>==</span> false <span style=color:#f92672>&amp;&amp;</span> dict.find(A.substr(<span style=color:#ae81ff>0</span>, i)) <span style=color:#f92672>!=</span> dict.end())
</span></span><span style=display:flex><span>            dp[i] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// go to all indices reachable from current index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (dp[i] <span style=color:#f92672>==</span> true){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> size)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>; a <span style=color:#f92672>&lt;=</span> size; a<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (dp[a] <span style=color:#f92672>==</span> false <span style=color:#f92672>&amp;&amp;</span> dict.find(A.substr(i, a<span style=color:#f92672>-</span>i)) <span style=color:#f92672>!=</span> dict.end())
</span></span><span style=display:flex><span>                    dp[a] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>==</span> size <span style=color:#f92672>&amp;&amp;</span> dp[a] <span style=color:#f92672>==</span> true)
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><p>In this function, we first initialize a boolean dp[] array as false. We then iterate through the string and for every ending position, we check whether a word ends at this position. If we get a prefix that is present in the dictionary, we update the dp value for this position and move forward.</p><p>Finally, we return dp[n] (n is the length of the input string) which indicates whether the input string can be segmented or not.</p><h2 id=dice-throw><strong>Dice throw</strong></h2><p>Given N dice each with M faces, numbered from 1 to M, find the number of ways to get sum X. X is the summation of values on each face when all the dice are thrown.</p><p>Example 1:</p><p>Input:
M = 6, N = 3, X = 12
Output:
25
Explanation:
There are 25 total ways to get
the Sum 12 using 3 dices with
faces from 1 to 6.</p><h2 id=solution-15>Solution</h2><p>The main idea here is to maintain a table dp[i][j] where dp[i][j] represents the number of ways to generate a sum of j using i dices.</p><p>To fill up the table, for each dice (from 1 to N), for each possible sum (from 1 to X), we add the number of ways to generate (current sum - face value) using one less dice.</p><p>Here is the C++ code:</p><h3 id=code-c-15>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>noOfWays</span>(<span style=color:#66d9ef>int</span> M , <span style=color:#66d9ef>int</span> N , <span style=color:#66d9ef>int</span> X)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Initializing the dp table
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;&gt;</span> dp(N<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span>(X<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If X is less than the number of dices, return 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(X <span style=color:#f92672>&lt;</span> N <span style=color:#f92672>||</span> X <span style=color:#f92672>&gt;</span> N<span style=color:#f92672>*</span>M) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// There is 1 way to get sum between 1 to M with 1 dice
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; j<span style=color:#f92672>&lt;=</span>M <span style=color:#f92672>&amp;&amp;</span> j<span style=color:#f92672>&lt;=</span>X; j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            dp[<span style=color:#ae81ff>1</span>][j] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Fill rest of the entries in dp[][]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// i: number of dices, j: sum
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>; i<span style=color:#f92672>&lt;=</span>N; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; j<span style=color:#f92672>&lt;=</span>X; j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> k<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; k<span style=color:#f92672>&lt;=</span>M <span style=color:#f92672>&amp;&amp;</span> k<span style=color:#f92672>&lt;</span>j; k<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    dp[i][j] <span style=color:#f92672>+=</span> dp[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j<span style=color:#f92672>-</span>k];
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Return number of ways to get sum X using N dices
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> dp[N][X];
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>This code initializes a dynamic programming table dp[N+1][X+1] where dp[i][j] represents the number of ways to make sum j using i dices. It then fills this table by considering all dices and sums smaller than the given sum. Finally, it returns the entry dp[N][X] which represents the number of ways to get sum X using N dices.</p><h2 id=egg-dropping-puzzle><strong>Egg Dropping Puzzle</strong></h2><p>You are given N identical eggs and you have access to a K-floored building from 1 to K.</p><p>There exists a floor f where 0 &lt;= f &lt;= K such that any egg dropped at a floor higher than f will break, and any egg dropped at or below floor f will not break. There are few rules given below.</p><pre><code>An egg that survives a fall can be used again.
A broken egg must be discarded.
The effect of a fall is the same for all eggs.
If the egg doesn't break at a certain floor, it will not break at any floor below.
If the eggs breaks at a certain floor, it will break at any floor above.
</code></pre><p>Return the minimum number of moves that you need to determine with certainty what the value of f is.</p><p>For more description on this problem see wiki page</p><h2 id=solution-16>Solution</h2><p>The approach is as follows:</p><pre><code>1. If we have only one egg, then we must try every floor one by one, starting from the first. Therefore, the worst case number of trials will be k (the number of floors).

2. If we have more than one egg, then we can use a binary approach. We drop an egg from a certain floor:

a. If it breaks, we know that the critical floor is below us, so we can ignore the floors above.

b. If it does not break, we know that the critical floor is above us, so we can ignore the floors below.
</code></pre><p>However, we don&rsquo;t know the exact floor from which to drop the egg to minimize the number of attempts. Hence, we must try dropping from each floor and calculate the worst case number of attempts, and finally, choose the floor which minimizes the worst case number of attempts.</p><h3 id=code-c-16>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>eggDrop</span>(<span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> k)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> dp(n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(k<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Base cases:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 1. If there is one floor, one trial is needed.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 2. If there are 0 floors, no trials are needed.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 3. If there is one egg, k trials are needed.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; i<span style=color:#f92672>&lt;=</span>n; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        dp[i][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        dp[i][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; j<span style=color:#f92672>&lt;=</span>k; j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        dp[<span style=color:#ae81ff>1</span>][j] <span style=color:#f92672>=</span> j;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Fill the rest of the entries in table dp[][]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// using optimal substructure property
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>; i<span style=color:#f92672>&lt;=</span>n; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>; j<span style=color:#f92672>&lt;=</span>k; j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            dp[i][j] <span style=color:#f92672>=</span> INT_MAX;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> x<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; x<span style=color:#f92672>&lt;=</span>j; x<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> max(dp[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][x<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>], dp[i][j<span style=color:#f92672>-</span>x]);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(res <span style=color:#f92672>&lt;</span> dp[i][j])
</span></span><span style=display:flex><span>                    dp[i][j] <span style=color:#f92672>=</span> res;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Return the minimum number of trials needed for n eggs and k floors
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> dp[n][k];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><p>This code fills up a 2D table dp where dp[i][j] will represent the minimum number of trials needed for i eggs and j floors. The worst-case number of trials needed for j floors and i eggs can be calculated using the optimal substructure property of the problem. The optimal solution for dp[i][j] will be 1 plus the maximum of dp[i-1][x-1] and dp[i][j-x] where x in this case is the floor at which we drop the egg. We loop over all possible x to find the minimum for dp[i][j]. Finally, dp[n][k] will give us the minimum number of trials needed for n eggs and k floors.</p><h2 id=max-length-chain><strong>Max length chain</strong></h2><p>You are given N pairs of numbers. In every pair, the first number is always smaller than the second number. A pair (c, d) can follow another pair (a, b) if b &lt; c. Chain of pairs can be formed in this fashion. You have to find the longest chain which can be formed from the given set of pairs.
Input:
N = 5
P[] = {5 24 , 39 60 , 15 28 , 27 40 , 50 90}
Output: 3
Explanation: The given pairs are { {5, 24}, {39, 60},
{15, 28}, {27, 40}, {50, 90} },the longest chain that
can be formed is of length 3, and the chain is
{{5, 24}, {27, 40}, {50, 90}}</p><h2 id=solution-17>Solution</h2><h3 id=code-c-17>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/*Non-DP Solution*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>val</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> first;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> second;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>compare</span>(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>val</span> a,<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>val</span> b)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a.second<span style=color:#f92672>&lt;</span>b.second;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>maxChainLen</span>(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>val</span> p[],<span style=color:#66d9ef>int</span> n)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        sort(p,p<span style=color:#f92672>+</span>n,compare);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> l<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>,prev<span style=color:#f92672>=</span>p[<span style=color:#ae81ff>0</span>].second;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;i<span style=color:#f92672>&lt;</span>n;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(p[i].first<span style=color:#f92672>&gt;</span>prev)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                prev<span style=color:#f92672>=</span>p[i].second; l<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> l;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><h2 id=--1>** **</h2><h2 id=solution-18>Solution</h2><p>At each turn, a player will choose the optimal strategy to maximize his score. The strategy will be to choose the maximum value from the front or back of the array. So, we keep track of the score difference between the two players.</p><p>If the final score difference is greater than or equal to zero, then player 1 wins.</p><p>Approach:</p><pre><code>1. We maintain a 2D table dp[i][j], where i and j are the starting and ending indices of the current subarray (i.e., the remaining elements in the array).

2. dp[i][j] stores the maximum score difference that player 1 can achieve over player 2 when only the subarray from index i to j is remaining.

3. For each subarray, player 1 has two choices, either to choose the element at the beginning or the end.

    a.  If he chooses the beginning element (arr[i]), then player 2 will be the first player for the remaining subarray [i+1, j]. So, the score difference will be arr[i] - dp[i+1][j].

    b. If he chooses the end element (arr[j]), then player 2 will be the first player for the remaining subarray [i, j-1]. So, the score difference will be arr[j] - dp[i][j-1].

4. Since player 1 wants to maximize his score difference, dp[i][j] will be the maximum of the two choices.
</code></pre><h3 id=code-c-18>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>is1winner</span>(<span style=color:#66d9ef>int</span> N,<span style=color:#66d9ef>int</span> arr[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> dp(N, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(N));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> gap <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; gap <span style=color:#f92672>&lt;</span> N; <span style=color:#f92672>++</span>gap)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, j <span style=color:#f92672>=</span> gap; j <span style=color:#f92672>&lt;</span> N; <span style=color:#f92672>++</span>i, <span style=color:#f92672>++</span>j)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> ((i<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>) <span style=color:#f92672>&lt;=</span> j) <span style=color:#f92672>?</span> dp[i<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>][j] <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> y <span style=color:#f92672>=</span> ((i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>&lt;=</span> (j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)) <span style=color:#f92672>?</span> dp[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>][j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> z <span style=color:#f92672>=</span> (i <span style=color:#f92672>&lt;=</span> (j<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>)) <span style=color:#f92672>?</span> dp[i][j<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>] <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            dp[i][j] <span style=color:#f92672>=</span> max(arr[i] <span style=color:#f92672>+</span> min(x, y), arr[j] <span style=color:#f92672>+</span> min(y, z));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> diff <span style=color:#f92672>=</span> dp[<span style=color:#ae81ff>0</span>][N<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (diff <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><h2 id=nth-fibonacci-numbe><strong>Nth Fibonacci Numbe</strong></h2><p>Given a positive integer n, find the nth fibonacci number. Since the answer can be very large, return the answer modulo 1000000007.(10e9+7)</p><h2 id=solution-19>Solution</h2><h3 id=code-c-19>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>nthFibonacci</span>(<span style=color:#66d9ef>int</span> n)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> dp[n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        dp[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        dp[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>;i<span style=color:#f92672>&lt;=</span>n;i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            dp[i] <span style=color:#f92672>=</span> (dp[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> dp[i<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>]) <span style=color:#f92672>%</span> <span style=color:#ae81ff>1000000007</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dp[n];
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=matrix-chain-multiplication><strong>Matrix Chain Multiplication</strong></h2><p>Given a sequence of matrices, find the most efficient way to multiply these matrices together. The efficient way is the one that involves the least number of multiplications.</p><p>The dimensions of the matrices are given in an array arr[] of size N (such that N = number of matrices + 1) where the ith matrix has the dimensions (arr[i-1] x arr[i]).</p><h2 id=solution-20>Solution</h2><p>In the Matrix Chain Multiplication problem, we are given a sequence of matrices and we need to figure out the most efficient way to multiply these matrices together. The problem is not actually to perform the multiplications, but merely to decide in which order to perform the multiplications.</p><p>This is a dynamic programming problem, and we can solve it by breaking it into sub-problems.</p><p>Let&rsquo;s define a 2D table dp[i][j] to represent the minimum number of scalar multiplications needed to compute the matrix Ai&mldr;Aj, where the dimension of Ai is arr[i-1] x arr[i].</p><p>Then we can iterate over all pairs (i, j) such that j > i, and for each pair we iterate over all possible splits k such that i &lt; k &lt; j, and we update dp[i][j] with the minimum cost of dp[i][k] + dp[k][j] + arr[i-1]*arr[k]*arr[j].</p><p>Here is the C++ code implementing this:</p><h3 id=code-c-20>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>matrixMultiplication</span>(<span style=color:#66d9ef>int</span> N, <span style=color:#66d9ef>int</span> arr[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dp[N][N];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>N; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        dp[i][i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>// cost is zero when multiplying one matrix.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> L<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>; L<span style=color:#f92672>&lt;</span>N; L<span style=color:#f92672>++</span>)  <span style=color:#75715e>// L is the chain length
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; i<span style=color:#f92672>&lt;</span>N<span style=color:#f92672>-</span>L<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i<span style=color:#f92672>+</span>L<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            dp[i][j] <span style=color:#f92672>=</span> INT_MAX;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> k<span style=color:#f92672>=</span>i; k<span style=color:#f92672>&lt;=</span>j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; k<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> q <span style=color:#f92672>=</span> dp[i][k] <span style=color:#f92672>+</span> dp[k<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>][j] <span style=color:#f92672>+</span> arr[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>*</span>arr[k]<span style=color:#f92672>*</span>arr[j];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(q <span style=color:#f92672>&lt;</span> dp[i][j])
</span></span><span style=display:flex><span>                    dp[i][j] <span style=color:#f92672>=</span> q;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dp[<span style=color:#ae81ff>1</span>][N<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><p>This code will return the minimum number of multiplications needed to multiply all the matrices together in the most efficient order. The time complexity of this solution is O(n^3), and it uses O(n^2) extra space to store the DP table.</p><h2 id=unique-bst><strong>Unique BST&rsquo;</strong></h2><p>Given an integer. Find how many structurally unique binary search trees are there that stores the values from 1 to that integer (inclusive).</p><h2 id=solution-21>Solution</h2><p>We are just calculating nth catalian number.</p><h3 id=code-c-21>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>numTrees</span>(<span style=color:#66d9ef>int</span> N) 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dp(N <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        dp[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        dp[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; i <span style=color:#f92672>&lt;=</span> N; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> i; <span style=color:#f92672>++</span>j)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                dp[i] <span style=color:#f92672>=</span> (dp[i]<span style=color:#f92672>+</span> ((dp[j]<span style=color:#f92672>%</span>MOD)<span style=color:#f92672>*</span>(dp[i <span style=color:#f92672>-</span> j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]<span style=color:#f92672>%</span>MOD))<span style=color:#f92672>%</span>MOD)<span style=color:#f92672>%</span>MOD;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dp[N]<span style=color:#f92672>%</span>MOD;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span></code></pre></div></div><div class=post-footer></div></article></main></body></html>