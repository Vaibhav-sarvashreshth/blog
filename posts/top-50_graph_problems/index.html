<!doctype html><html lang=en-us><head><title>Top 50 Graph Questions // Vaibhav's Blogs</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.117.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Christopher Hart"><meta name=description content><link rel=stylesheet href=/blog/css/main.min.3c3c186cd62e563ad6e2f00a89dbee656ab912d1d46f856b5605dd0232521e2a.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Top 50 Graph Questions"><meta name=twitter:description content="Top 50 Graph Problems Looking to master graph theory and solve graph problems efficiently? You&rsquo;re in the right place! This blog provides solutions to the top 50 graph problems along with multiple approaches for each problem. We also ensure that the written code is well-commented for better understanding.
Graphs are essential data structures used in various fields, including computer science, data analysis, and network analysis. By gaining proficiency in graph theory and problem-solving, you can enhance your skills and tackle complex challenges effectively."><meta property="og:title" content="Top 50 Graph Questions"><meta property="og:description" content="Top 50 Graph Problems Looking to master graph theory and solve graph problems efficiently? You&rsquo;re in the right place! This blog provides solutions to the top 50 graph problems along with multiple approaches for each problem. We also ensure that the written code is well-commented for better understanding.
Graphs are essential data structures used in various fields, including computer science, data analysis, and network analysis. By gaining proficiency in graph theory and problem-solving, you can enhance your skills and tackle complex challenges effectively."><meta property="og:type" content="article"><meta property="og:url" content="https://Vaibhav-sarvashreshth.github.io/blog/posts/top-50_graph_problems/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-20T15:10:44+05:30"><meta property="article:modified_time" content="2023-07-20T15:10:44+05:30"></head><body><header class=app-header><a href=https://Vaibhav-sarvashreshth.github.io/blog/><img class=app-header-avatar src=/blog/avatar.jpg alt="Christopher Hart"></a>
<span class=app-header-title>Vaibhav's Blogs</span><nav class=app-header-menu><a class=app-header-menu-item href=/blog/tags/>Tags</a></nav><p>A blog about all things technical.</p><div class=app-header-social><a href=https://github.com/Vaibhav-sarvashreshth target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://github.com/Vaibhav-sarvashreshth target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Top 50 Graph Questions</h1><div class=post-meta><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Jul 20, 2023</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>31 min read</div></div></header><div class=post-content><h1 id=top-50-graph-problems>Top 50 Graph Problems</h1><p>Looking to master graph theory and solve graph problems efficiently? You&rsquo;re in the right place! This blog provides solutions to the top 50 graph problems along with multiple approaches for each problem. We also ensure that the written code is well-commented for better understanding.</p><p>Graphs are essential data structures used in various fields, including computer science, data analysis, and network analysis. By gaining proficiency in graph theory and problem-solving, you can enhance your skills and tackle complex challenges effectively.</p><p>List Of Questions :</p><ul><li><a href=#number-of-provinces>Number of Provinces</a></li><li><a href=#find-the-number-of-islands>Find the number of islands</a></li><li><a href=#detect-cycle-in-an-undirected-graph>Detect cycle in an undirected graph</a></li><li><a href=#hamiltonian-path>Hamiltonian Path</a></li><li><a href=#prerequisite-tasks>Prerequisite Tasks</a></li><li><a href=#course-schedule>Course Schedule</a></li><li><a href=#circle-of-strings>Circle of Strings</a></li><li><a href=#snake-and-ladder-problem>Snake and Ladder problem</a></li><li><a href=#bipartite-graph>Bipartite Graph</a></li><li><a href=#maximum-bipartite-matching>Maximum Bipartite Matching</a></li><li><a href=#detect-cycle-in-a-directed-graph>Detect cycle in a directed graph</a></li><li><a href=#find-whether-path-exists>Find whether path exists</a></li><li><a href=#topological-sort>Topological Sort</a></li><li><a href=#level-of-nodes>Level of Nodes</a></li><li><a href=#possible-paths-between-2-vertices>Possible paths between 2 vertices</a></li><li><a href=#x-total-shapes>X Total Shapes</a></li><li><a href=#distance-of-nearest-cell-having-1>Distance of nearest cell having 1</a></li><li><a href=#mother-vertex>Mother Vertex</a></li><li><a href=#unit-area-of-largest-region-of-1s>Unit Area of largest region of 1’s</a></li><li><a href=#rotten-oranges>Rotten Oranges</a></li><li><a href=#minimum-swaps-to-sort>Minimum Swaps to Sort</a></li><li><a href=#steps-by-knight>Steps by Knight</a></li><li><a href=#implementing-dijkstra-algorithm>Implementing Dijkstra Algorithm</a></li><li><a href=#neemans-shoes>Neeman’s Shoes</a></li><li><a href=#minimum-spanning-tree>Minimum Spanning Tree</a></li><li><a href=#strongly-connected-components-kosarajus-algo>Strongly Connected Components (Kosaraju’s Algo)</a></li><li><a href=#bridge-edge-in-graph>Bridge Edge in Graph</a></li><li><a href=#flood-fill-algorithm>Flood Fill Algorithm</a></li><li><a href=#replace-os-with-xs>Replace O’s with X’s</a></li><li><a href=#shortest-prime-path>Shortest Prime Path</a></li><li><a href=#word-search>Word Search</a></li><li><a href=#construct-binary-palindrome-by-repeated-appending-and-trimming>Construct binary palindrome by repeated appending and trimming</a></li><li><a href=#word-boggle>Word Boggle</a></li></ul><h1 id=graph-problem-heading>Graph Problem Heading</h1><h2 id=print-adjacency-list><strong>Print adjacency list</strong></h2><p>Given the adjacency list of a bidirectional graph. Your task is to copy/clone the adjacency list for each vertex and return a new list.</p><h3 id=code-c>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> printGraph(<span style=color:#66d9ef>int</span> V, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> adj[])
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> graph(V);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> k<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(k<span style=color:#f92672>&lt;</span>V)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            graph[k].push_back(k);
</span></span><span style=display:flex><span>            k<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>V;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> x : adj[i])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                graph[i].push_back(x);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> graph;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=bfs-of-graph><strong>BFS of graph</strong></h2><p>Given a directed graph. The task is to do Breadth First Traversal of this graph starting from 0.</p><p><code>Note</code>: One can move from node u to node v only if there&rsquo;s an edge from u to v and find the BFS traversal of the graph starting from the 0th vertex, from left to right according to the graph. Also, you should only take nodes directly or indirectly connected from Node 0 in consideration.</p><h3 id=solution>Solution</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> bfsOfGraph(<span style=color:#66d9ef>int</span> V, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> adj[])
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Vector to store the nodes visited in BFS order
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> nodes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Array to keep track of visited nodes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> visited[V] <span style=color:#f92672>=</span> {false};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Create a queue for BFS traversal
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Start BFS from vertex 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        q.push(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        visited[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Perform BFS traversal
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>q.empty())
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> front <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>            nodes.push_back(front);
</span></span><span style=display:flex><span>            q.pop();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Traverse all adjacent nodes of the current node
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> node : adj[front])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If the adjacent node is not visited, mark it as visited,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// add it to the visited nodes vector, and enqueue it for further traversal
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>visited[node])
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    visited[node] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>                    q.push(node);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Return the vector containing the nodes visited in BFS order
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> nodes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=dfs-of-graph><strong>DFS of Graph</strong></h2><p>You are given a connected undirected graph. Perform a Depth First Traversal of the graph.
Note: Use a recursive approach to find the DFS traversal of the graph starting from the 0th vertex from left to right according to the graph.</p><h3 id=solution-1>Solution</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Depth First Traversal (DFS) of a Graph
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * This code implements a recursive approach to perform a Depth First Traversal (DFS) of a connected undirected graph.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The DFS traversal starts from the 0th vertex and explores all reachable vertices from each visited vertex.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The traversal order is from left to right according to the graph.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> adj[],<span style=color:#66d9ef>int</span> i,vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&amp;</span>visited,vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span>ans)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>            visited[i]<span style=color:#f92672>=</span>true;
</span></span><span style=display:flex><span>            ans.push_back(i);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> vertex : adj[i])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>visited[vertex])
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    dfs(adj,vertex,visited,ans);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dfsOfGraph(<span style=color:#66d9ef>int</span> V, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> adj[])
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> ans;
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> visited(V,false);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>V;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>visited[i])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                dfs(adj,i,visited,ans);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=number-of-provinces><strong>Number of Provinces</strong></h2><p>Given an undirected graph with V vertices. We say two vertices u and v belong to a single province if there is a path from u to v or v to u. Your task is to find the number of provinces.</p><p>Note: A province is a group of directly or indirectly connected cities and no other cities outside of the group.</p><h3 id=solution-using-bfs><strong>Solution (using BFS)</strong></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;queue&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Breadth-First Search (BFS) function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>bfs</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> adj, <span style=color:#66d9ef>int</span> V, <span style=color:#66d9ef>int</span> N, <span style=color:#66d9ef>bool</span><span style=color:#f92672>*</span> visited) {
</span></span><span style=display:flex><span>queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q;
</span></span><span style=display:flex><span>visited[N] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>q.push(N);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>q.empty()) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> top <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>    q.pop();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> V; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>visited[i] <span style=color:#f92672>&amp;&amp;</span> adj[top][i]) {
</span></span><span style=display:flex><span>            q.push(i);
</span></span><span style=display:flex><span>            visited[i] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Function to find the number of provinces in the graph
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>numProvinces</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> adj, <span style=color:#66d9ef>int</span> V) {
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> visited[V] <span style=color:#f92672>=</span> { false };
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> no_of_provinces <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> V; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>visited[i]) {
</span></span><span style=display:flex><span>        bfs(adj, V, i, visited);
</span></span><span style=display:flex><span>        no_of_provinces<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> no_of_provinces;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=solution-using-dfs><strong>Solution (using DFS)</strong></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> index, vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> adj, <span style=color:#66d9ef>int</span> visited[], <span style=color:#66d9ef>int</span> V)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        visited[index] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> V; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(adj[index][i] and visited[i] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                visited[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                dfs(i, adj, visited, V);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>numProvinces</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> adj, <span style=color:#66d9ef>int</span> V) {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> visited[V] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> comp <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> V; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>visited[i])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                comp<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                dfs(i, adj, visited, V);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> comp;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=find-the-number-of-islands><strong>Find the number of islands</strong></h2><p>Given a grid of size n*m (n is the number of rows and m is the number of columns in the grid) consisting of &lsquo;0&rsquo;s (Water) and &lsquo;1&rsquo;s(Land). Find the number of islands.</p><p>Note: An island is either surrounded by water or boundary of grid and is formed by connecting adjacent lands horizontally or vertically or diagonally i.e., in all 8 directions.</p><h3 id=solution-2><strong>Solution</strong></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> vis[<span style=color:#ae81ff>501</span>][<span style=color:#ae81ff>501</span>]<span style=color:#f92672>=</span>{{<span style=color:#ae81ff>0</span>}};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n,m;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dx[<span style=color:#ae81ff>8</span>] <span style=color:#f92672>=</span> { <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dy[<span style=color:#ae81ff>8</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>val</span>(<span style=color:#66d9ef>int</span> r,<span style=color:#66d9ef>int</span> c)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(r<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> r<span style=color:#f92672>&gt;=</span>n <span style=color:#f92672>||</span> c<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> c<span style=color:#f92672>&gt;=</span>m)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> r,<span style=color:#66d9ef>int</span> c)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        vis[r][c]<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>8</span>;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> nr<span style=color:#f92672>=</span>r<span style=color:#f92672>+</span>dx[i];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> nc<span style=color:#f92672>=</span>c<span style=color:#f92672>+</span>dy[i];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(val(nr,nc) <span style=color:#f92672>&amp;&amp;</span> vis[nr][nc]<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                dfs(nr,nc);
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>numIslands</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;&amp;</span> grid)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Code here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        n<span style=color:#f92672>=</span>grid.size();
</span></span><span style=display:flex><span>        m<span style=color:#f92672>=</span>grid[<span style=color:#ae81ff>0</span>].size();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> no_of_island<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>n;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;j<span style=color:#f92672>&lt;</span>m;j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(grid[i][j]<span style=color:#f92672>==</span><span style=color:#e6db74>&#39;0&#39;</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    vis[i][j]<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>n;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;j<span style=color:#f92672>&lt;</span>m;j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>vis[i][j])
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    dfs(i,j);
</span></span><span style=display:flex><span>                    no_of_island<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                }   
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> no_of_island;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=detect-cycle-in-an-undirected-graph><strong>Detect cycle in an undirected graph</strong></h2><p>Given an undirected graph with V vertices and E edges, check whether it contains any cycle or not. Graph is in the form of adjacency list where adj[i] contains all the nodes ith node is having edge with.</p><h3 id=solution-3><strong>Solution</strong></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Depth-First Search (DFS) function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>dfs</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> adj[], vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&amp;</span> visited, <span style=color:#66d9ef>int</span> source, <span style=color:#66d9ef>int</span> parent) {
</span></span><span style=display:flex><span>visited[source] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> node : adj[source]) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (visited[node] <span style=color:#f92672>==</span> false) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (dfs(adj, visited, node, source)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (node <span style=color:#f92672>!=</span> parent) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Function to check whether the graph contains any cycle
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isCycle</span>(<span style=color:#66d9ef>int</span> V, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> adj[]) {
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> visited(V, false);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> V; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (visited[i] <span style=color:#f92672>==</span> false) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (dfs(adj, visited, i, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=hamiltonian-path><strong>Hamiltonian Path</strong></h2><p>A Hamiltonian path, is a path in an undirected graph that visits each vertex exactly once. Given an undirected graph, the task is to check if a Hamiltonian path is present in it or not.</p><h3 id=solution-4><strong>Solution</strong></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> n, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> adj[], vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>vist, <span style=color:#66d9ef>int</span> src){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(n<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        vist[src]<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>x:adj[src]){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(vist[x]<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>){
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(dfs(n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,adj,vist,x)){
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        vist[src]<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>check</span>(<span style=color:#66d9ef>int</span> N,<span style=color:#66d9ef>int</span> M,vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> Edges)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// code here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> n<span style=color:#f92672>=</span> N, m<span style=color:#f92672>=</span> M;
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> adj[n];
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>x:Edges){
</span></span><span style=display:flex><span>            adj[x[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>].push_back(x[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            adj[x[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>].push_back(x[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> vist(n,<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>n;i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(dfs(n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,adj,vist,i)){
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=prerequisite-tasks><strong>Prerequisite Tasks</strong></h2><p>There are a total of N tasks, labeled from 0 to N-1. Some tasks may have prerequisites, for example to do task 0 you have to first complete task 1, which is expressed as a pair: [0, 1]
Given the total number of tasks N and a list of prerequisite pairs P, find if it is possible to finish all tasks.</p><h3 id=solution-5><strong>Solution</strong></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isPossible</span>(<span style=color:#66d9ef>int</span> N, vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&gt;&amp;</span> prerequisites) {
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// Code here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> N;
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> graph(n);
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> indegree(n,<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> c : prerequisites)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            graph[c.second].push_back(c.first);
</span></span><span style=display:flex><span>            indegree[c.first]<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> toposort;
</span></span><span style=display:flex><span>        queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>n;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(indegree[i]<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>) 
</span></span><span style=display:flex><span>                q.push(i);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>q.empty())
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> curr <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>            q.pop();
</span></span><span style=display:flex><span>            toposort.push_back(curr);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> nbr: graph[curr])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                indegree[nbr]<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(indegree[nbr]<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>) 
</span></span><span style=display:flex><span>                    q.push(nbr);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(toposort.size()<span style=color:#f92672>!=</span>n) 
</span></span><span style=display:flex><span>        	<span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>        	
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><h2 id=course-schedule><strong>Course Schedule</strong></h2><p>There are a total of n tasks you have to pick, labeled from 0 to n-1. Some tasks may have prerequisites tasks, for example to pick task 0 you have to first finish tasks 1, which is expressed as a pair: [0, 1]
Given the total number of n tasks and a list of prerequisite pairs of size m. Find a ordering of tasks you should pick to finish all tasks.
Note: There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all tasks, return an empty array. Returning any correct order will give the output as 1, whereas any invalid order will give the output &ldquo;No Ordering Possible&rdquo;.</p><h3 id=solution-using-kosarajus-algorithm><strong>Solution (Using Kosarajus Algorithm)</strong></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> i ,vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>adj,vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>visited , vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>recursive_stack ,stack<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span>answer)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>         recursive_stack[i]<span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>         visited[i]<span style=color:#f92672>=</span>true;
</span></span><span style=display:flex><span>         
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> node: adj[i])
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>visited[node])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(dfs(node,adj,visited,recursive_stack,answer))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(recursive_stack[node]<span style=color:#f92672>==</span>true)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        answer.push(i);
</span></span><span style=display:flex><span>        recursive_stack[i]<span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> findOrder(<span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> m, vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> prerequisites) 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//code here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>ordering;
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>visited(n,<span style=color:#ae81ff>0</span>),recursive_stack(n,<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> adj(n);
</span></span><span style=display:flex><span>	    stack<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>answer;
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// converting the list into adj matrix
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	     <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> prerequisite : prerequisites) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> course <span style=color:#f92672>=</span> prerequisite[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> prerequisiteCourse <span style=color:#f92672>=</span> prerequisite[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>            adj[prerequisiteCourse].push_back(course);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// now traversing through adj using dfs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>n;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>	    {
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>visited[i])
</span></span><span style=display:flex><span>	        {
</span></span><span style=display:flex><span>	            <span style=color:#66d9ef>if</span>(dfs(i,adj,visited,recursive_stack,answer))
</span></span><span style=display:flex><span>	            {
</span></span><span style=display:flex><span>	                
</span></span><span style=display:flex><span>	                <span style=color:#66d9ef>return</span> {};
</span></span><span style=display:flex><span>	            }
</span></span><span style=display:flex><span>	        }
</span></span><span style=display:flex><span>	    }
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>answer.empty()) {
</span></span><span style=display:flex><span>            ordering.push_back(answer.top());
</span></span><span style=display:flex><span>            answer.pop();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ordering;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=solution-using-kahns-algorithm-for-topological-sorting><strong>Solution (Using Kahn’s algorithm for Topological Sorting)</strong></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> findOrder(<span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> m, vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> prerequisites) 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Here I used Kahns algorithm, first will find the inorder of all nodes, if we found
</span></span></span><span style=display:flex><span><span style=color:#75715e>        inorder=0 for a node, then we will push it in a queue, to traverse the graph like we did in BFS.
</span></span></span><span style=display:flex><span><span style=color:#75715e>        Then through that node we will travserv the other nodes, decrementing their indegrees.
</span></span></span><span style=display:flex><span><span style=color:#75715e>        */</span>
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>graph(n);
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>indegree(n,<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>q;
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>toposort;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>m;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            graph[prerequisites[i][<span style=color:#ae81ff>1</span>]].push_back(prerequisites[i][<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>            indegree[prerequisites[i][<span style=color:#ae81ff>0</span>]]<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>n;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(indegree[i]<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                q.push(i);
</span></span><span style=display:flex><span>                toposort.push_back(i);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>q.empty())
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> front <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>            q.pop();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> node : graph[front])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                indegree[node]<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(indegree[node]<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    q.push(node);
</span></span><span style=display:flex><span>                    toposort.push_back(node);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(toposort.size() <span style=color:#f92672>!=</span> n)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> toposort;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=circle-of-strings><strong>Circle of strings</strong></h2><p>Given an array of lowercase strings A[] of size N, determine if the strings can be chained together to form a circle.
A string X can be chained together with another string Y if the last character of X is same as first
character of Y. If every string of the array can be chained, it will form a circle.</p><p>For example, for the array arr[] = {&ldquo;for&rdquo;, &ldquo;geek&rdquo;, &ldquo;rig&rdquo;, &ldquo;kaf&rdquo;} the answer will be Yes as the given strings can be chained as &ldquo;for&rdquo;, &ldquo;rig&rdquo;, &ldquo;geek&rdquo; and &ldquo;kaf&rdquo;</p><h3 id=solution-6><strong>Solution</strong></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> node, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> adj[], vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>vis)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        vis[node]<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> child: adj[node])
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(vis[child]<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                dfs(child,adj,vis);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>isCircle</span>(<span style=color:#66d9ef>int</span> N, vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> A)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n<span style=color:#f92672>=</span> N;
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> adj[<span style=color:#ae81ff>26</span>];
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> in(<span style=color:#ae81ff>26</span>,<span style=color:#ae81ff>0</span>), out(<span style=color:#ae81ff>26</span>,<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>n;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> ch1<span style=color:#f92672>=</span>A[i][<span style=color:#ae81ff>0</span>]<span style=color:#f92672>-</span><span style=color:#e6db74>&#39;a&#39;</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> ch2<span style=color:#f92672>=</span>A[i].back()<span style=color:#f92672>-</span><span style=color:#e6db74>&#39;a&#39;</span>;
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            adj[ch1].push_back(ch2); <span style=color:#75715e>//linking all componenets to form a eulerian cycle and test later
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// so here we are linking the first character and the last character of a string together
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>            in[ch2]<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            out[ch1]<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> vis(<span style=color:#ae81ff>26</span>,<span style=color:#ae81ff>0</span>); 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> src<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>26</span>;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(in[i]<span style=color:#f92672>!=</span>out[i])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>26</span>;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(out[i]<span style=color:#f92672>!=</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                src<span style=color:#f92672>=</span>i;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        dfs(src,adj,vis);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>26</span>;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(vis[i]<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> out[i])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=bipartite-graph><strong>Bipartite Graph</strong></h2><p>Given an adjacency list of a graph adj of V no. of vertices having 0 based index. Check whether the graph is bipartite or not.</p><h3 id=solution-7><strong>Solution</strong></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isBipartite</span>(<span style=color:#66d9ef>int</span> V, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>adj[])
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*This code works on a simple principle that, while traversing the graph, you first color the first node and then you color all its neighbour with alternate color, and you keep on repeating the process. While doing so, if you found any node which is already colored and has the same color as the parent node, then its not the bi-partite graph. Else it is. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// this code works for disconnected as well as connected graph
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// consider red as 0 and blue as 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>color(V,<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>	    queue<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>q; <span style=color:#75715e>// first -&gt; node, second -&gt; color
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>V;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>	    {
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>if</span>(color[i]<span style=color:#f92672>==-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	        {
</span></span><span style=display:flex><span>	            color[i]<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	            q.push({i,<span style=color:#ae81ff>0</span>});
</span></span><span style=display:flex><span>	            <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>q.empty())
</span></span><span style=display:flex><span>    	        {
</span></span><span style=display:flex><span>    	            
</span></span><span style=display:flex><span>    	            pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> front <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>        	        q.pop();
</span></span><span style=display:flex><span>        	        <span style=color:#66d9ef>int</span> node <span style=color:#f92672>=</span> front.first;
</span></span><span style=display:flex><span>        	        <span style=color:#66d9ef>int</span> col <span style=color:#f92672>=</span> front.second;
</span></span><span style=display:flex><span>        	        
</span></span><span style=display:flex><span>        	        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> neighbour : adj[node])
</span></span><span style=display:flex><span>        	        {
</span></span><span style=display:flex><span>        	            <span style=color:#66d9ef>if</span>(color[neighbour] <span style=color:#f92672>==</span> col)
</span></span><span style=display:flex><span>        	            {
</span></span><span style=display:flex><span>        	                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        	            }
</span></span><span style=display:flex><span>        	            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(color[neighbour]<span style=color:#f92672>==-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        	            {
</span></span><span style=display:flex><span>        	                color[neighbour] <span style=color:#f92672>=</span> (col)<span style=color:#f92672>?</span>(<span style=color:#ae81ff>0</span>)<span style=color:#f92672>:</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        	                q.push({neighbour,color[neighbour]});
</span></span><span style=display:flex><span>        	            }
</span></span><span style=display:flex><span>        	        }
</span></span><span style=display:flex><span>    	            
</span></span><span style=display:flex><span>    	        }
</span></span><span style=display:flex><span>	            
</span></span><span style=display:flex><span>	        }
</span></span><span style=display:flex><span>	        
</span></span><span style=display:flex><span>	    }
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><h2 id=detect-cycle-in-a-directed-graph><strong>Detect cycle in a directed graph</strong></h2><p>Given a Directed Graph with V vertices (Numbered from 0 to V-1) and E edges, check whether it contains any cycle or not.</p><h3 id=solution-8><strong>Solution</strong></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> i ,vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> adj[],vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>visited , vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>recursive_stack )
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>         recursive_stack[i]<span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>         visited[i]<span style=color:#f92672>=</span>true;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> node: adj[i])
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>visited[node])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(dfs(node,adj,visited,recursive_stack))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(recursive_stack[node]<span style=color:#f92672>==</span>true) <span style=color:#75715e>// that means if it is visited and also present in a recursive stack , which means cycle is present 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        recursive_stack[i]<span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isCyclic</span>(<span style=color:#66d9ef>int</span> V, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> adj[])
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>visited(V,<span style=color:#ae81ff>0</span>),recursive_stack(V,<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>V;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> node : adj[i])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>visited[i])
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// note that dfs function here returns true if cycle is present and returns false when cycle is not present
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span>(dfs(i,adj,visited,recursive_stack))
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=find-whether-path-exist><strong>Find whether path exist</strong></h2><p>Given a grid of size n*n filled with 0, 1, 2, 3. Check whether there is a path possible from the source to destination. You can traverse up, down, right and left.
The description of cells is as follows:</p><p>A value of cell 1 means Source.<br>A value of cell 2 means Destination.<br>A value of cell 3 means Blank cell.<br>A value of cell 0 means Wall.</p><p>Note: There are only a single source and a single destination.</p><h3 id=solution-using-bfs-1><strong>Solution Using BFS</strong></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dx[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> { <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dy[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>val</span>(<span style=color:#66d9ef>int</span> x,<span style=color:#66d9ef>int</span> y,<span style=color:#66d9ef>int</span> n)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(x<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> y<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> x<span style=color:#f92672>&gt;=</span>n <span style=color:#f92672>||</span> y<span style=color:#f92672>&gt;=</span>n)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>is_Possible</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> grid) 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//code here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> n<span style=color:#f92672>=</span>grid.size();
</span></span><span style=display:flex><span>        queue<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>q;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>n;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;j<span style=color:#f92672>&lt;</span>n;j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(grid[i][j]<span style=color:#f92672>==</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    q.push({i,j});
</span></span><span style=display:flex><span>                    grid[i][j]<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>q.empty())
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> x<span style=color:#f92672>=</span>q.front().first;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> y<span style=color:#f92672>=</span>q.front().second;
</span></span><span style=display:flex><span>            q.pop();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>4</span>;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> nx<span style=color:#f92672>=</span>x<span style=color:#f92672>+</span>dx[i];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> ny<span style=color:#f92672>=</span>y<span style=color:#f92672>+</span>dy[i];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(val(nx,ny,n)<span style=color:#f92672>==</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> grid[nx][ny]<span style=color:#f92672>!=</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span>(grid[nx][ny]<span style=color:#f92672>==</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//here just aking sure that, we do not visit the same vertex twice, so making 3 to 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>                    grid[nx][ny]<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                    q.push({nx,ny});
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h3 id=solution-using-dfs-1><strong>Solution Using DFS</strong></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y, vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> v)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(x<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> x<span style=color:#f92672>&gt;=</span>v.size() <span style=color:#f92672>||</span> y<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> y<span style=color:#f92672>&gt;=</span>v.size() <span style=color:#f92672>||</span> v[x][y]<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(v[x][y]<span style=color:#f92672>==</span><span style=color:#ae81ff>2</span>) <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>        v[x][y] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> ans <span style=color:#f92672>=</span> dfs(x<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,y,v) <span style=color:#f92672>||</span> dfs(x<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,y,v) <span style=color:#f92672>||</span> dfs(x,y<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,v) <span style=color:#f92672>||</span> dfs(x,y<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,v);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>is_Possible</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> v) 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> v.size();
</span></span><span style=display:flex><span>        queue<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> q;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>n;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;j<span style=color:#f92672>&lt;</span>n;j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(v[i][j]<span style=color:#f92672>==</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span>(dfs(i,j,v)) <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=topological-sort><strong>Topological sort</strong></h2><p>Given a Directed Acyclic Graph (DAG) with V vertices and E edges, Find any Topological Sorting of that Graph.</p><h3 id=solution-bfs-kahns-algo><strong>Solution BFS (Kahn&rsquo;s Algo)</strong></h3><p>BFS Approach || Kahn&rsquo;s Algo
Idea</p><p>The idea is that all nodes which will be at starting will have indegree 0.</p><p><code>Algorithm</code></p><p>Store Indegree of all nodes in Array.<br>Push nodes in Queue whose indegree == 0.<br>Now, For each node in Queue.<br>Pop the current node & Store into resultant Array<br>Remove indegree count of all neighbours of current node.<br>If neighbours indegree becomes 0 the push into queue.<br>Finally, return resultant Array.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> topoSort(<span style=color:#66d9ef>int</span> V, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> adj[])
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>	    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span>	    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> indegree(V, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> V; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> nbr : adj[i])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>	            indegree[nbr]<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>	        }
</span></span><span style=display:flex><span>	    }
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	    queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q;
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> V; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>if</span>(indegree[i] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>	            q.push(i);
</span></span><span style=display:flex><span>	        }
</span></span><span style=display:flex><span>	    }
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>q.empty())
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>int</span> curr <span style=color:#f92672>=</span> q.front(); q.pop();
</span></span><span style=display:flex><span>	        res.push_back(curr);
</span></span><span style=display:flex><span>	        
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> nbr : adj[curr])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>	            indegree[nbr]<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>	            <span style=color:#66d9ef>if</span>(indegree[nbr] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) q.push(nbr);
</span></span><span style=display:flex><span>	        }
</span></span><span style=display:flex><span>	    }
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><h3 id=solution-dfs-approach><strong>Solution DFS Approach</strong></h3><p><code>Idea</code></p><p>Node that comes at last must be present at last. Hence, the idea is to store last visited at bottom. Thus, Stack comes into picture.</p><p><code>Algorithm</code></p><p>Make visited Array to tackle both disconnected & visited Nodes.
Call DFS on each unvisited node
Call DFS on unvisited Neighbours
After making all calls to Neighbours Store current Node in a Stack.
Finally, pop all the elements of stack into resultant Vector</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> start, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>vis, stack<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>s, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> adj[])
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>	    vis[start] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> nbr : adj[start])
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>vis[nbr])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>	            dfs(nbr, vis, s, adj);
</span></span><span style=display:flex><span>	        }
</span></span><span style=display:flex><span>	    }
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	    s.push(start);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> topoSort(<span style=color:#66d9ef>int</span> V, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> adj[])
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>	    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> vis(V);
</span></span><span style=display:flex><span>	    stack<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s;
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> V; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>vis[i])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>	            dfs(i, vis, s, adj);
</span></span><span style=display:flex><span>	        }
</span></span><span style=display:flex><span>	    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> V; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>	        res.push_back(s.top()); 
</span></span><span style=display:flex><span>            s.pop();
</span></span><span style=display:flex><span>	    }
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><h2 id=level-of-nodes><strong>Level Of Nodes</strong></h2><p>Given a Undirected Graph with V vertices and E edges, Find the level of node X. if X does not exist in the graph then print -1.
Note: Traverse the graph starting from vertex 0.</p><h2 id=solution-9>Solution</h2><p>Just do a simple BFS and , when node_we_want == it , then just return level +1 (here level variable is the level of the parent).</p><h3 id=code-c-1>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>nodeLevel</span>(<span style=color:#66d9ef>int</span> V, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> adj[], <span style=color:#66d9ef>int</span> X) 
</span></span><span style=display:flex><span>	{   
</span></span><span style=display:flex><span>	    queue<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&gt;</span> q; 
</span></span><span style=display:flex><span>	    q.push({<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>});
</span></span><span style=display:flex><span>	    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span> <span style=color:#f92672>&gt;</span> vis(V , <span style=color:#ae81ff>0</span> );
</span></span><span style=display:flex><span>	    vis[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> ;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>q.empty())
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>int</span> node <span style=color:#f92672>=</span> q.front().first;
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>int</span> level <span style=color:#f92672>=</span> q.front().second;
</span></span><span style=display:flex><span>	        q.pop();
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> it : adj[node])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>	            <span style=color:#66d9ef>if</span>(X <span style=color:#f92672>==</span> it)<span style=color:#66d9ef>return</span> level <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> ;
</span></span><span style=display:flex><span>	            <span style=color:#66d9ef>if</span>(vis[it] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> )
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>	                q.push({it,level <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> });
</span></span><span style=display:flex><span>	                vis[it] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	            }
</span></span><span style=display:flex><span>	               
</span></span><span style=display:flex><span>	        }
</span></span><span style=display:flex><span>	    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><h2 id=possible-paths-between-2-vertices><strong>Possible paths between 2 vertices</strong></h2><p>Given a Directed Graph having V nodes numbered from 0 to V-1, and E directed edges. Given two nodes, source and destination, count the number of ways or paths between these two vertices in the directed graph. These paths should not contain any cycle.
Note: Graph doesn&rsquo;t contain multiple edges, self-loop, and cycles.</p><h2 id=solution-10>Solution</h2><p>Just do a BFS starting from source and if you found a node such that node == destination, then increment res and continue the loop. If you doesnt find a node == destination then put all its neighbours into queue.</p><h3 id=code-c-2>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>countPaths</span>(<span style=color:#66d9ef>int</span> V, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> adj[], <span style=color:#66d9ef>int</span> source, <span style=color:#66d9ef>int</span> destination) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q;
</span></span><span style=display:flex><span>        q.push(source);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>q.empty())
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> currentNode <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>            q.pop();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (currentNode <span style=color:#f92672>==</span> destination)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                res<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> neighbor : adj[currentNode])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                q.push(neighbor);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=x-total-shapes><strong>X Total Shapes</strong></h2><p>Given a grid of n*m consisting of O&rsquo;s and X&rsquo;s. The task is to find the number of &lsquo;X&rsquo; total shapes.
Note: &lsquo;X&rsquo; shape consists of one or more adjacent X&rsquo;s (diagonals not included).</p><h2 id=solution-11>Solution</h2><p>Easy problem, just do a DFS and mark the nodes as visited.
The no of times you are going to do DFS the no of X total shapes will be there.</p><h3 id=code-c-3>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/* here I used vis array of 100 * 100 dimension , you can create a dynamic vector
</span></span></span><span style=display:flex><span><span style=color:#75715e>and allocate the size accordingly, I just didnt done that beacause I am lazy to push it aas a parameter in every function :) 
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> vis[<span style=color:#ae81ff>100</span>][<span style=color:#ae81ff>100</span>]<span style=color:#f92672>=</span>{{<span style=color:#ae81ff>0</span>}};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dx[<span style=color:#ae81ff>4</span>]<span style=color:#f92672>=</span>{<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dy[<span style=color:#ae81ff>4</span>]<span style=color:#f92672>=</span>{<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n1,m1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>val</span>(<span style=color:#66d9ef>int</span> r,<span style=color:#66d9ef>int</span> c)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(r<span style=color:#f92672>&gt;=</span>n1 <span style=color:#f92672>||</span> r<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> c<span style=color:#f92672>&gt;=</span>m1 <span style=color:#f92672>||</span> c<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> r,<span style=color:#66d9ef>int</span> c , vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;&amp;</span> grid)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        vis[r][c]<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>4</span>;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> nr<span style=color:#f92672>=</span>r<span style=color:#f92672>+</span>dx[i];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> nc<span style=color:#f92672>=</span>c<span style=color:#f92672>+</span>dy[i];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(vis[nr][nc]<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> val(nr,nc)<span style=color:#f92672>==</span>true <span style=color:#f92672>&amp;&amp;</span> grid[nr][nc]<span style=color:#f92672>!=</span><span style=color:#e6db74>&#39;O&#39;</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                dfs(nr,nc,grid);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>xShape</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;&amp;</span> grid) 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Code here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> count<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> r<span style=color:#f92672>=</span>grid.size();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> c<span style=color:#f92672>=</span>grid[<span style=color:#ae81ff>0</span>].size();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>        n1<span style=color:#f92672>=</span>r;
</span></span><span style=display:flex><span>        m1<span style=color:#f92672>=</span>c;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>r;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;j<span style=color:#f92672>&lt;</span>c;j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>vis[i][j] <span style=color:#f92672>&amp;&amp;</span> grid[i][j]<span style=color:#f92672>!=</span><span style=color:#e6db74>&#39;O&#39;</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    dfs(i,j,grid);
</span></span><span style=display:flex><span>                    count<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> count;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=distance-of-nearest-cell-having-1><strong>Distance of nearest cell having 1</strong></h2><p>Given a binary grid of n*m. Find the distance of the nearest 1 in the grid for each cell.
The distance is calculated as |i1 - i2| + |j1 - j2|, where i1, j1 are the row number and column number of the current cell, and i2, j2 are the row number and column number of the nearest cell having value 1. There should be atleast one 1 in the grid.</p><h2 id=solution-12>Solution</h2><h3 id=code-c-4>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dx[<span style=color:#ae81ff>4</span>]<span style=color:#f92672>=</span>{<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dy[<span style=color:#ae81ff>4</span>]<span style=color:#f92672>=</span>{<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>val</span>(<span style=color:#66d9ef>int</span> nx,<span style=color:#66d9ef>int</span> ny,<span style=color:#66d9ef>int</span> r,<span style=color:#66d9ef>int</span> c)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(nx<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> nx<span style=color:#f92672>&gt;=</span>r <span style=color:#f92672>||</span> ny<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> ny<span style=color:#f92672>&gt;=</span>c)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>nearest(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>grid)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// Code here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    <span style=color:#66d9ef>int</span> r<span style=color:#f92672>=</span>grid.size();
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>int</span> c<span style=color:#f92672>=</span>grid[<span style=color:#ae81ff>0</span>].size();
</span></span><span style=display:flex><span>	    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> v(r,vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(c,<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>	    queue<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>q;
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>r;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>	    {
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;j<span style=color:#f92672>&lt;</span>c;j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>	        {
</span></span><span style=display:flex><span>	            <span style=color:#66d9ef>if</span>(grid[i][j]<span style=color:#f92672>==</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	            {
</span></span><span style=display:flex><span>	                <span style=color:#75715e>// if block is 1 then push in queue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	                v[i][j]<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	                q.push({i,j});
</span></span><span style=display:flex><span>	            }
</span></span><span style=display:flex><span>	        }
</span></span><span style=display:flex><span>	    }
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>q.empty())
</span></span><span style=display:flex><span>	    {
</span></span><span style=display:flex><span>	        pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> curr<span style=color:#f92672>=</span>q.front();
</span></span><span style=display:flex><span>	        q.pop();
</span></span><span style=display:flex><span>	        
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>4</span>;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>	        {
</span></span><span style=display:flex><span>	            <span style=color:#66d9ef>int</span> nx<span style=color:#f92672>=</span>curr.first<span style=color:#f92672>+</span>dx[i];
</span></span><span style=display:flex><span>	            <span style=color:#66d9ef>int</span> ny<span style=color:#f92672>=</span>curr.second<span style=color:#f92672>+</span>dy[i];
</span></span><span style=display:flex><span>	            
</span></span><span style=display:flex><span>	            <span style=color:#66d9ef>if</span>(val(nx,ny,r,c) <span style=color:#f92672>&amp;&amp;</span> v[nx][ny]<span style=color:#f92672>==-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	            {
</span></span><span style=display:flex><span>	                v[nx][ny]<span style=color:#f92672>=</span>v[curr.first][curr.second]<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	                q.push({nx,ny});
</span></span><span style=display:flex><span>	                
</span></span><span style=display:flex><span>	            }
</span></span><span style=display:flex><span>	        }
</span></span><span style=display:flex><span>	    }
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>return</span> v;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><h2 id=mother-vertex><strong>Mother Vertex</strong></h2><p>Given a Directed Graph, find a Mother Vertex in the Graph (if present).
A Mother Vertex is a vertex through which we can reach all the other vertices of the Graph.</p><h2 id=solution-13>Solution</h2><p>Do a DFS from every vertex and after doing DFS if no of visited vertex +1(including mother vertex) == no of titial vertex, then
it is a mother vertex.</p><h3 id=code-c-5>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> src,vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>vec[],vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span>visited,<span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>count)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        visited[src] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> e:vec[src])
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>visited[e])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                count<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                dfs(e,vec,visited,count);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>findMotherVertex</span>(<span style=color:#66d9ef>int</span> V, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>adj[])
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>int</span> n<span style=color:#f92672>=</span>V;
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>n;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>visited(n,false);
</span></span><span style=display:flex><span>	        
</span></span><span style=display:flex><span>	        dfs(i,adj,visited,count);
</span></span><span style=display:flex><span>	        
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>if</span>(count<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span style=color:#f92672>==</span>n)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>	            <span style=color:#66d9ef>return</span> i;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>	    }   
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><h2 id=unit-area-of-largest-region-of-1s><strong>Unit Area of largest region of 1&rsquo;s</strong></h2><p>Given a grid of dimension nxm containing 0s and 1s. Find the unit area of the largest region of 1s.
Region of 1&rsquo;s is a group of 1&rsquo;s connected 8-directionally (horizontally, vertically, diagonally).</p><h2 id=solution-14>Solution</h2><p>Same as <a href=#x-total-shapes>X Total Shapes</a>. Just we have to maintaine a max varialbe which will store tyhe maximum value of area.</p><h3 id=code-c-6>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n,m,count<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>,max<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dx[<span style=color:#ae81ff>8</span>] <span style=color:#f92672>=</span> { <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dy[<span style=color:#ae81ff>8</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>val</span>(<span style=color:#66d9ef>int</span> r,<span style=color:#66d9ef>int</span> c)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(r<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> r<span style=color:#f92672>&gt;=</span>n <span style=color:#f92672>||</span> c<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> c<span style=color:#f92672>&gt;=</span>m)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> r,<span style=color:#66d9ef>int</span> c, vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> visited)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        visited[r][c]<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        count<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(max<span style=color:#f92672>&lt;</span>count)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            max <span style=color:#f92672>=</span> count;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>8</span>;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> nr<span style=color:#f92672>=</span>r<span style=color:#f92672>+</span>dx[i];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> nc<span style=color:#f92672>=</span>c<span style=color:#f92672>+</span>dy[i];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(val(nr,nc) <span style=color:#f92672>&amp;&amp;</span> visited[nr][nc]<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                dfs(nr,nc,visited);
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>findMaxArea</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> grid)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> grid.size();
</span></span><span style=display:flex><span>        m <span style=color:#f92672>=</span> grid[<span style=color:#ae81ff>0</span>].size();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> no_of_islands<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> visited(n,vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(m,<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>n;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;j<span style=color:#f92672>&lt;</span>m;j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(grid[i][j]<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    visited[i][j]<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>n;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;j<span style=color:#f92672>&lt;</span>m;j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>visited[i][j])
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    dfs(i,j,visited);
</span></span><span style=display:flex><span>                    count<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                }   
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> max;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=rotten-oranges><strong>Rotten Oranges</strong></h2><p>Given a grid of dimension nxm where each cell in the grid can have values 0, 1 or 2 which has the following meaning:
0 : Empty cell
1 : Cells have fresh oranges
2 : Cells have rotten oranges</p><p>We have to determine what is the minimum time required to rot all oranges. A rotten orange at index [i,j] can rot other fresh orange at indexes [i-1,j], [i+1,j], [i,j-1], [i,j+1] (up, down, left and right) in unit time.</p><h2 id=solution-15>Solution</h2><p>Here approach is that, you have to store all rotten oranges in a queue and then make their neighbour oranges rooten.
And then push them into queue. And then increment the time by 1. Do this till all oranges get rotted.</p><h3 id=code-c-7>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dx[<span style=color:#ae81ff>4</span>]<span style=color:#f92672>=</span>{<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dy[<span style=color:#ae81ff>4</span>]<span style=color:#f92672>=</span>{<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>val</span>(<span style=color:#66d9ef>int</span> nx,<span style=color:#66d9ef>int</span> ny,<span style=color:#66d9ef>int</span> r,<span style=color:#66d9ef>int</span> c)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(nx<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> nx<span style=color:#f92672>&gt;=</span>r <span style=color:#f92672>||</span> ny<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> ny<span style=color:#f92672>&gt;=</span>c)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>orangesRotting</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> grid)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> r<span style=color:#f92672>=</span>grid.size();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> c<span style=color:#f92672>=</span>grid[<span style=color:#ae81ff>0</span>].size();
</span></span><span style=display:flex><span>        queue<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> q;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> ans<span style=color:#f92672>=-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>r;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;j<span style=color:#f92672>&lt;</span>c;j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(grid[i][j]<span style=color:#f92672>==</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    q.push({i,j});
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>q.empty())
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> qs<span style=color:#f92672>=</span>q.size();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span>(qs<span style=color:#f92672>--</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>auto</span> curr<span style=color:#f92672>=</span>q.front();
</span></span><span style=display:flex><span>                q.pop();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>4</span>;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> nx<span style=color:#f92672>=</span>curr.first<span style=color:#f92672>+</span>dx[i];
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> ny<span style=color:#f92672>=</span>curr.second<span style=color:#f92672>+</span>dy[i];
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span>(val(nx,ny,r,c) <span style=color:#f92672>&amp;&amp;</span> grid[nx][ny]<span style=color:#f92672>==</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        grid[nx][ny]<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>                        q.push({nx,ny});
</span></span><span style=display:flex><span>                        
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            ans<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>r;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;j<span style=color:#f92672>&lt;</span>c;j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(grid[i][j]<span style=color:#f92672>==</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=steps-by-knight><strong>Steps by Knight</strong></h2><p>Given a square chessboard, the initial position of Knight and position of a target. Find out the minimum steps a Knight will take to reach the target position.</p><p>Note:
The initial and the target position coordinates of Knight have been given according to 1-base indexing.</p><h2 id=solution-16>Solution</h2><h3 id=code-c-8>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dx[<span style=color:#ae81ff>8</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>2</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>1</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dy[<span style=color:#ae81ff>8</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>2</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>};
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// global variable dist
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> dist;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>check</span>(<span style=color:#66d9ef>int</span> x,<span style=color:#66d9ef>int</span> y,<span style=color:#66d9ef>int</span> N)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (x <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> y <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> x <span style=color:#f92672>&lt;=</span> N <span style=color:#f92672>&amp;&amp;</span> y <span style=color:#f92672>&lt;=</span> N);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>minStepToReachTarget</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span>KnightPos,vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span>TargetPos,<span style=color:#66d9ef>int</span> N)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>if</span>(KnightPos[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> TargetPos[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&amp;&amp;</span> KnightPos[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> TargetPos[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>	    {
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	    }
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	    dist <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>(N<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(N<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// initialize with N+1 as indexing start from 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    
</span></span><span style=display:flex><span>        queue<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> q;
</span></span><span style=display:flex><span>	    q.push(make_pair(KnightPos[<span style=color:#ae81ff>0</span>],KnightPos[<span style=color:#ae81ff>1</span>]));
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>q.empty())
</span></span><span style=display:flex><span>	    {
</span></span><span style=display:flex><span>            pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> xx <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>            q.pop();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>8</span>;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> nr<span style=color:#f92672>=</span>xx.first <span style=color:#f92672>+</span> dx[i];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> nc<span style=color:#f92672>=</span>xx.second <span style=color:#f92672>+</span> dy[i];
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(check(nr,nc,N) <span style=color:#f92672>&amp;&amp;</span> (dist[nr][nc]) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    dist[nr][nc] <span style=color:#f92672>=</span> dist[xx.first][xx.second] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                    q.push(make_pair(nr,nc));
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span>(nr<span style=color:#f92672>==</span>TargetPos[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&amp;&amp;</span> nc<span style=color:#f92672>==</span>TargetPos[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> dist[TargetPos[<span style=color:#ae81ff>0</span>]][TargetPos[<span style=color:#ae81ff>1</span>]];
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// if still not return then that eans its imoossible 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// return -1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><h2 id=implementing-dijkstra-algorithm><strong>Implementing Dijkstra Algorithm</strong></h2><p>Given a weighted, undirected and connected graph of V vertices and an adjacency list adj where adj[i] is a list of lists containing two integers where the first integer of each list j denotes there is edge between i and j , second integers corresponds to the weight of that edge . You are given the source vertex S and You to Find the shortest distance of all the vertex&rsquo;s from the source vertex S. You have to return a list of integers denoting shortest distance between each node and Source vertex S.</p><p>Note: The Graph doesn&rsquo;t contain any negative weight cycle.</p><h2 id=solution-17>Solution</h2><p>Dijkstra&rsquo;s algorithm works by visiting vertices in the graph starting with the object&rsquo;s starting vertex, S, and it iterates a greedy loop over the edge of the vertex set. The algorithm keeps track of the currently known shortest distance from each node to the source node and it updates these values if it finds a shorter path.</p><h3 id=code-c-9>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span>vector <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dijkstra(<span style=color:#66d9ef>int</span> V, vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&gt;&amp;</span> adj, <span style=color:#66d9ef>int</span> S)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create a priority queue to store vertices that
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// are being preprocessed. This is weird syntax in C++.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Refer below explanation for syntax.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    priority_queue<span style=color:#f92672>&lt;</span> pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>, vector <span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> , greater<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&gt;</span> pq;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create a vector for distances and initialize all
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// distances as infinite (INF)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dist(V, INT_MAX);
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Insert source itself in priority queue and initialize
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// its distance as 0.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    pq.push(make_pair(<span style=color:#ae81ff>0</span>, S));
</span></span><span style=display:flex><span>    dist[S] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Looping till priority queue becomes empty (or all
</span></span></span><span style=display:flex><span><span style=color:#75715e>      distances are not finalized) */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>pq.empty())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The first vertex in pair is the minimum distance
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// vertex, extract it from priority queue.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// vertex label is stored in second of pair (it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// has to be done this way to keep the vertices
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// sorted distance (distance must be first item
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// in pair)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> u <span style=color:#f92672>=</span> pq.top().second;
</span></span><span style=display:flex><span>        pq.pop();
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>        <span style=color:#75715e>// &#39;i&#39; is used to get all adjacent vertices of a vertex
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;::</span>iterator i;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> adj[u].begin(); i <span style=color:#f92672>!=</span> adj[u].end(); <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Get vertex label and weight of current adjacent
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// of u.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> (<span style=color:#f92672>*</span>i).first;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> weight <span style=color:#f92672>=</span> (<span style=color:#f92672>*</span>i).second;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>            <span style=color:#75715e>//  If there is shorted path to v through u.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (dist[v] <span style=color:#f92672>&gt;</span> dist[u] <span style=color:#f92672>+</span> weight)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Updating distance of v
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                dist[v] <span style=color:#f92672>=</span> dist[u] <span style=color:#f92672>+</span> weight;
</span></span><span style=display:flex><span>                pq.push(make_pair(dist[v], v));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dist;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><h2 id=neemans-shoes><strong>Neeman&rsquo;s Shoes</strong></h2><p>Due to the second wave of Gorona virus, Geekland imposed another lockdown and Geek has gained some wieght. Now Geek has decided to exercise.
There are N intersections in the city numbered from 0 to N-1 and M bidirectional roads each road connecting two intersections. All the intersections are connected to each-other through some set of roads, ith road connect intersections A[i][0] and A[i][1] and is of length A[i][2].
Every morning Geek will start at intersection src and will run/walk upto intersection dest. Geek only has one hour in the morning so he will choose to cover the shortest path from src to dest.
After planning his exercising schedule, Geek wants to buy the perfect shoes to walk/run in the morning. He goes to Neeman&rsquo;s Shoe factory which is the National Shoe factory of Geekland.</p><p>Geek sees that there are two types of shoes &ldquo;Neeman&rsquo;s Wool Joggers&rdquo; and &ldquo;Neeman&rsquo;s Cotton Classics&rdquo;, &ldquo;Neeman&rsquo;s Wool Joggers&rdquo; are good for running and &ldquo;Neeman&rsquo;s Cotton Classics&rdquo; are good for walking.
Geek is confused which shoes to buy, so he comes up with a strategy. If the distance he has to cover in the morning is less than or equal to X, then he will walk the distance, therefore he will buy &ldquo;Neeman&rsquo;s Cotton Classics&rdquo;. If the distance is greater than X, he will buy &ldquo;Neeman&rsquo;s Wool Joggers&rdquo;. Geek is too lazy to calculate the shortest distance between two intersections src and dest. Help him decide which shoes to buy.</p><h2 id=solution-18>Solution</h2><h3 id=code-c-10>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>typedef</span> pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> iPair; 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    string <span style=color:#a6e22e>exercise</span>(<span style=color:#66d9ef>int</span> N, <span style=color:#66d9ef>int</span> M, vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> A, <span style=color:#66d9ef>int</span> src, <span style=color:#66d9ef>int</span> dest, <span style=color:#66d9ef>int</span> X)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>     vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>adj[N] ;
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>for</span>( <span style=color:#66d9ef>auto</span> i : A )
</span></span><span style=display:flex><span>       {
</span></span><span style=display:flex><span>           adj[i[<span style=color:#ae81ff>0</span>]].push_back({ i[<span style=color:#ae81ff>1</span>] , i[<span style=color:#ae81ff>2</span>]}) ;
</span></span><span style=display:flex><span>           adj[i[<span style=color:#ae81ff>1</span>]].push_back({ i[<span style=color:#ae81ff>0</span>] , i[<span style=color:#ae81ff>2</span>]}) ;
</span></span><span style=display:flex><span>           
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>       vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>distance( N , INT_MAX ) ;
</span></span><span style=display:flex><span>       distance[src] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> ;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       priority_queue<span style=color:#f92672>&lt;</span>iPair, vector<span style=color:#f92672>&lt;</span>iPair<span style=color:#f92672>&gt;</span>, greater<span style=color:#f92672>&lt;</span>iPair<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&gt;</span>pq;
</span></span><span style=display:flex><span>       pq.push({ <span style=color:#ae81ff>0</span> , src }) ;
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>pq.empty())
</span></span><span style=display:flex><span>       {
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>int</span> u <span style=color:#f92672>=</span> pq.top().second ;
</span></span><span style=display:flex><span>           pq.pop() ;
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>for</span>( <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> ; j <span style=color:#f92672>&lt;</span> adj[u].size() ; j<span style=color:#f92672>++</span> )
</span></span><span style=display:flex><span>           {
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> adj[u][j][<span style=color:#ae81ff>0</span>] ;
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>int</span> weight <span style=color:#f92672>=</span>  adj[u][j][<span style=color:#ae81ff>1</span>] ;
</span></span><span style=display:flex><span>               
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>if</span>( distance[u] <span style=color:#f92672>+</span> weight <span style=color:#f92672>&lt;</span> distance[v])
</span></span><span style=display:flex><span>               {
</span></span><span style=display:flex><span>                   distance[v] <span style=color:#f92672>=</span> distance[u] <span style=color:#f92672>+</span> weight ;
</span></span><span style=display:flex><span>                   pq.push({ distance[v] , v }) ;
</span></span><span style=display:flex><span>               }
</span></span><span style=display:flex><span>           }
</span></span><span style=display:flex><span>           
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>int</span> d <span style=color:#f92672>=</span> distance[dest] ;
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>if</span>(d<span style=color:#f92672>&lt;=</span>X)
</span></span><span style=display:flex><span>       {
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>return</span>  <span style=color:#e6db74>&#34;Neeman&#39;s Cotton Classics&#34;</span> ;
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Neeman&#39;s Wool Joggers&#34;</span> ;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><h2 id=minimum-spanning-tree><strong>Minimum Spanning Tree</strong></h2><p>Given a weighted, undirected and connected graph of V vertices and E edges. The task is to find the sum of weights of the edges of the Minimum Spanning Tree.</p><h2 id=solution-19>Solution</h2><h3 id=code-c-11>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>spanningTree</span>(<span style=color:#66d9ef>int</span> V, vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> adj[])
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        priority_queue<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>,vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>,greater<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&gt;</span>pq;
</span></span><span style=display:flex><span>       pq.push({<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>});
</span></span><span style=display:flex><span>       vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>visit(V,false);
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>int</span> ans<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>pq.empty()){
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>auto</span> p<span style=color:#f92672>=</span>pq.top();
</span></span><span style=display:flex><span>           pq.pop();
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>int</span> x<span style=color:#f92672>=</span>p.second;
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>int</span> w<span style=color:#f92672>=</span>p.first;
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>if</span>(visit[x])<span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>           visit[x]<span style=color:#f92672>=</span>true;
</span></span><span style=display:flex><span>           ans<span style=color:#f92672>+=</span>w;
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> y:adj[x]){
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>visit[y[<span style=color:#ae81ff>0</span>]]){
</span></span><span style=display:flex><span>                   pq.push({y[<span style=color:#ae81ff>1</span>],y[<span style=color:#ae81ff>0</span>]});
</span></span><span style=display:flex><span>               }
</span></span><span style=display:flex><span>           }
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><h2 id=strongly-connected-components-kosarajus-algo><strong>Strongly Connected Components (Kosaraju&rsquo;s Algo)</strong></h2><p>Given a Directed Graph with V vertices (Numbered from 0 to V-1) and E edges, Find the number of strongly connected components in the graph.</p><h2 id=solution-20>Solution</h2><p>Approach :</p><pre><code>sort the graph topologically and store it in the stack.
transpose the given graph
do the dfs(accordig to the top element of the stack you got from topo sort) and count everytime you run the dfs
</code></pre><h3 id=code-c-12>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> n, vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> adj, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>v, stack<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>st)
</span></span><span style=display:flex><span>{       
</span></span><span style=display:flex><span>        v[n] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> ch : adj[n])
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>v[ch])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                v[ch] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                dfs(ch, adj, v, st);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        st.push(n);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Simple DFS on transposed Graph
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>tdfs</span>(<span style=color:#66d9ef>int</span> n, vector <span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>adj, vector <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>v)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>       v[n] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> k : adj[n])
</span></span><span style=display:flex><span>       {
</span></span><span style=display:flex><span>           
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>v[k])
</span></span><span style=display:flex><span>           {
</span></span><span style=display:flex><span>               v[k] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>               tdfs(k, adj, v);
</span></span><span style=display:flex><span>           }
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>    }   
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>kosaraju</span>(<span style=color:#66d9ef>int</span> V, vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> adj)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        vector <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> visited(V, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        stack <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> st;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Take on Stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;i <span style=color:#f92672>&lt;</span> V;i <span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>visited[i])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                dfs(i, adj, visited, st);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Transpose Of Graph
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        vector <span style=color:#f92672>&lt;</span>vector <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> trans(V);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;i <span style=color:#f92672>&lt;</span> V;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            visited[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// Reset visited 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> nr : adj[i])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                trans[nr].push_back(i);        
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>        <span style=color:#75715e>// DFS 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> ans <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>st.empty())
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> tp <span style=color:#f92672>=</span> st.top();
</span></span><span style=display:flex><span>            st.pop();
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>visited[tp])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                tdfs(tp, trans, visited);
</span></span><span style=display:flex><span>                ans<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><h2 id=bridge-edge-in-a-graph><strong>Bridge edge in a graph</strong></h2><p>Given a Graph of V vertices and E edges and another edge(c - d), the task is to find if the given edge is a Bridge. i.e., removing the edge disconnects the graph.</p><h2 id=solution-21>Solution</h2><p>If in a graph we start traversing from a given node C with a given condition (as in LINE 15) [please read conditions]
and even then if node D gets visited, it means there is another edge available in the graph to reach D.
Because of this, even if the edge from C to D is removed, the Graph will not be divided into two components.</p><p>So, if node D gets visited, it means the edge from C to D is not a Bridge.
And if node D remains UNVISITED even after traversing the entire graph, it means the edge from C to D is a BRIDGE.</p><h3 id=code-c-13>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>( <span style=color:#66d9ef>int</span> node, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> adj[], <span style=color:#66d9ef>int</span> c , <span style=color:#66d9ef>int</span> d,vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>visited)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>	    visited[node] <span style=color:#f92672>=</span> true ; 
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> nbr : adj[node])
</span></span><span style=display:flex><span>	    {
</span></span><span style=display:flex><span>	        <span style=color:#66d9ef>if</span>( <span style=color:#f92672>!</span>visited[nbr] <span style=color:#f92672>&amp;&amp;</span> (node<span style=color:#f92672>!=</span>c <span style=color:#f92672>||</span> nbr <span style=color:#f92672>!=</span> d) )
</span></span><span style=display:flex><span>	        dfs(nbr, adj, c, d, visited ) ; 
</span></span><span style=display:flex><span>	    }
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>isBridge</span>(<span style=color:#66d9ef>int</span> V, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> adj[], <span style=color:#66d9ef>int</span> c, <span style=color:#66d9ef>int</span> d) 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> visited(V, false) ;
</span></span><span style=display:flex><span>        dfs( c , adj , c, d , visited ) ;<span style=color:#75715e>//send C as initial node 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>!</span>visited[d] ; 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><h2 id=->** **</h2><h2 id=solution-22>Solution</h2><h3 id=code-c-14>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    
</span></span></code></pre></div><h2 id=flood-fill-algorithm><strong>Flood fill Algorithm</strong></h2><p>An image is represented by a 2-D array of integers, each integer representing the pixel value of the image.</p><p>Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, &ldquo;flood fill&rdquo; the image.</p><p>To perform a &ldquo;flood fill&rdquo;, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor.</p><h2 id=solution-23>Solution</h2><p>Just a simple DFS question.</p><h3 id=code-c-15>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> r ;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> c ;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dx[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dy[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> oldColor;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> image, <span style=color:#66d9ef>int</span> sr, <span style=color:#66d9ef>int</span> sc, <span style=color:#66d9ef>int</span> newColor,vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> visited)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        visited[sr][sc] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>4</span>;i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> dx[i]<span style=color:#f92672>+</span>sr;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> y <span style=color:#f92672>=</span> dy[i]<span style=color:#f92672>+</span>sc;
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(x <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> x <span style=color:#f92672>&lt;</span> r <span style=color:#f92672>&amp;&amp;</span> y <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> y <span style=color:#f92672>&lt;</span> c <span style=color:#f92672>&amp;&amp;</span> image[x][y] <span style=color:#f92672>==</span> oldColor <span style=color:#f92672>&amp;&amp;</span> visited[x][y]<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>  )
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    image[x][y] <span style=color:#f92672>=</span> newColor;
</span></span><span style=display:flex><span>                    dfs(image,x,y,newColor,visited);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> floodFill(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> image, <span style=color:#66d9ef>int</span> sr, <span style=color:#66d9ef>int</span> sc, <span style=color:#66d9ef>int</span> newColor)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Code here 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        r <span style=color:#f92672>=</span> image.size();
</span></span><span style=display:flex><span>        c <span style=color:#f92672>=</span> image[<span style=color:#ae81ff>0</span>].size();
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>visited(r,vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(c,<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        oldColor <span style=color:#f92672>=</span> image[sr][sc];
</span></span><span style=display:flex><span>        image[sr][sc] <span style=color:#f92672>=</span> newColor;
</span></span><span style=display:flex><span>        dfs(image,sr,sc,newColor,visited);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> image;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=replace-os-with-xs><strong>Replace O&rsquo;s with X&rsquo;s</strong></h2><p>Given a matrix mat of size N x M where every element is either O or X.
Replace all O with X that are surrounded by X.
A O (or a set of O) is considered to be surrounded by X if there are X at locations just below, just above, just left and just right of it.</p><p>Example 1:</p><p>Input: n = 5, m = 4
mat = {{&lsquo;X&rsquo;, &lsquo;X&rsquo;, &lsquo;X&rsquo;, &lsquo;X&rsquo;},
{&lsquo;X&rsquo;, &lsquo;O&rsquo;, &lsquo;X&rsquo;, &lsquo;X&rsquo;},
{&lsquo;X&rsquo;, &lsquo;O&rsquo;, &lsquo;O&rsquo;, &lsquo;X&rsquo;},
{&lsquo;X&rsquo;, &lsquo;O&rsquo;, &lsquo;X&rsquo;, &lsquo;X&rsquo;},
{&lsquo;X&rsquo;, &lsquo;X&rsquo;, &lsquo;O&rsquo;, &lsquo;O&rsquo;}}
Output: ans = {{&lsquo;X&rsquo;, &lsquo;X&rsquo;, &lsquo;X&rsquo;, &lsquo;X&rsquo;},
{&lsquo;X&rsquo;, &lsquo;X&rsquo;, &lsquo;X&rsquo;, &lsquo;X&rsquo;},
{&lsquo;X&rsquo;, &lsquo;X&rsquo;, &lsquo;X&rsquo;, &lsquo;X&rsquo;},
{&lsquo;X&rsquo;, &lsquo;X&rsquo;, &lsquo;X&rsquo;, &lsquo;X&rsquo;},
{&lsquo;X&rsquo;, &lsquo;X&rsquo;, &lsquo;O&rsquo;, &lsquo;O&rsquo;}}
Explanation: Following the rule the above
matrix is the resultant matrix.</p><h2 id=solution-24>Solution</h2><pre><code>We will use boundary DFS to solve this problem
    
Let's analyze when an 'O' cannot be flipped,
if it has atleast one 'O' in it's adjacent, AND ultimately this chain of adjacent 'O's is connected to some 'O' which lies on boundary of board
    
consider these two cases for clarity :
  
    O's won't be flipped          O's will be flipped
    [X O X X X]                   [X X X X X]     
    [X O O O X]                   [X O O O X]
    [X O X X X]                   [X O X X X] 
    [X X X X X]                   [X X X X X]
  
  So we can conclude if a chain of adjacent O's is connected some O on boundary then they cannot be flipped
  

    
  Steps to Solve :
  1. Move over the boundary of board, and find O's 
  2. Every time we find an O, perform DFS from it's position
  3. In DFS convert all 'O' to '#'      (why?? so that we can differentiate which 'O' can be flipped and which cannot be)   
  4. After all DFSs have been performed, board contains three elements,#,O and X
  5. 'O' are left over elements which are not connected to any boundary O, so flip them to 'X'
  6. '#' are elements which cannot be flipped to 'X', so flip them back to 'O'
</code></pre><h3 id=code-c-16>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>DFS</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;&amp;</span> mat, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j, <span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> m)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span> or j<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span> or i<span style=color:#f92672>&gt;=</span>n or j<span style=color:#f92672>&gt;=</span>m or mat[i][j] <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;O&#39;</span>) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        mat[i][j] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;#&#39;</span>;
</span></span><span style=display:flex><span>        DFS(mat, i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, j, n, m);
</span></span><span style=display:flex><span>        DFS(mat, i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, j, n, m);
</span></span><span style=display:flex><span>        DFS(mat, i, j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, n, m);
</span></span><span style=display:flex><span>        DFS(mat, i, j<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, n, m);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span> fill(<span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> m, vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span> mat)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> mat;  
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>         
</span></span><span style=display:flex><span>         <span style=color:#75715e>//Moving over firts and last column   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>if</span>(mat[i][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;O&#39;</span>)
</span></span><span style=display:flex><span>                 DFS(mat, i, <span style=color:#ae81ff>0</span>, n, m);
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>if</span>(mat[i][m<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;O&#39;</span>)
</span></span><span style=display:flex><span>                 DFS(mat, i, m<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, n, m);
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>         <span style=color:#75715e>//Moving over first and last row   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; j<span style=color:#f92672>&lt;</span>m; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>if</span>(mat[<span style=color:#ae81ff>0</span>][j] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;O&#39;</span>)
</span></span><span style=display:flex><span>                 DFS(mat, <span style=color:#ae81ff>0</span>, j, n, m);
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>if</span>(mat[n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;O&#39;</span>)
</span></span><span style=display:flex><span>                 DFS(mat, n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, j, n, m);
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>n; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; j<span style=color:#f92672>&lt;</span>m; j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>             {
</span></span><span style=display:flex><span>                 <span style=color:#66d9ef>if</span>(mat[i][j] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;O&#39;</span>)
</span></span><span style=display:flex><span>                     mat[i][j] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;X&#39;</span>;
</span></span><span style=display:flex><span>                 <span style=color:#66d9ef>if</span>(mat[i][j] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;#&#39;</span>)
</span></span><span style=display:flex><span>                     mat[i][j] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;O&#39;</span>;
</span></span><span style=display:flex><span>             }
</span></span><span style=display:flex><span>     
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> mat;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><h2 id=word-search><strong>Word Search</strong></h2><p>Given a 2D board of letters and a word. Check if the word exists in the board. The word can be constructed from letters of adjacent cells only. ie - horizontal or vertical neighbors. The same letter cell can not be used more than once.</p><p>Example 1:</p><p>Input: board = {{a,g,b,c},{q,e,e,l},{g,b,k,s}},
word = &ldquo;geeks&rdquo;
Output: 1
Explanation: The board is-
a g b c
q e e l
g b k s
The letters which are used to make the
&ldquo;geeks&rdquo; are colored.</p><p>Example 2:</p><p>Input: board = {{a,b,c,e},{s,f,c,s},{a,d,e,e}},
word = &ldquo;sabfs&rdquo;
Output: 0
Explanation: The board is-
a b c e
s f c s
a d e e
Same letter can not be used twice hence ans is 0</p><h2 id=solution-25>Solution</h2><h3 id=code-c-17>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>solve</span>(<span style=color:#66d9ef>int</span>  i , <span style=color:#66d9ef>int</span> j , <span style=color:#66d9ef>int</span> ind , string word , vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>board , vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;</span>vis)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>if</span>(ind <span style=color:#f92672>==</span> word.size())
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> board.size(), m <span style=color:#f92672>=</span> board[<span style=color:#ae81ff>0</span>].size();
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>if</span>(i<span style=color:#f92672>&gt;=</span> n <span style=color:#f92672>||</span> j<span style=color:#f92672>&gt;=</span>m <span style=color:#f92672>||</span> i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> j<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> vis[i][j]<span style=color:#f92672>==</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> board[i][j] <span style=color:#f92672>!=</span> word[ind])
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>     
</span></span><span style=display:flex><span>       vis[i][j]  <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>if</span>(solve(i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> , j , ind <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> , word , board , vis) <span style=color:#f92672>||</span> 
</span></span><span style=display:flex><span>       solve(i , j<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> , ind <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> , word , board , vis) <span style=color:#f92672>||</span> 
</span></span><span style=display:flex><span>       solve(i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> , j , ind <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> , word , board , vis) <span style=color:#f92672>||</span> 
</span></span><span style=display:flex><span>       solve(i , j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> , ind <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> , word , board , vis))
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       vis[i][j] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isWordExist</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;&amp;</span> board, string word)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Code here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> board[<span style=color:#ae81ff>0</span>].size() , n <span style=color:#f92672>=</span> board.size();
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> vis(n , vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> (m , <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span>  i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> ;i <span style=color:#f92672>&lt;</span> n ; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> ; j   <span style=color:#f92672>&lt;</span> m ; j<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(board[i][j] <span style=color:#f92672>==</span> word[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>                  <span style=color:#66d9ef>if</span>(solve(i, j , <span style=color:#ae81ff>0</span> , word , board , vis))
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=construct-binary-palindrome-by-repeated-appending-and-trimming><strong>Construct binary palindrome by repeated appending and trimming</strong></h2><p>Given n and k, Construct a palindrome of size n using the binary representation of the number k.To construct the palindrome you can use the binary number of size k as many times as you wish and also you can trim all the zeros from the end.The palindrome must always begin with 1 and contains the maximum number of zeros.</p><h2 id=solution-26>Solution</h2><h3 id=code-c-18>Code (C++)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    string <span style=color:#a6e22e>binaryPalindrome</span>(<span style=color:#66d9ef>int</span> n,<span style=color:#66d9ef>int</span> k)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>       <span style=color:#75715e>// Complete the function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       string s(n,<span style=color:#e6db74>&#39;0&#39;</span>);
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>n;)
</span></span><span style=display:flex><span>       {
</span></span><span style=display:flex><span>               s[i]<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;1&#39;</span>;
</span></span><span style=display:flex><span>               s[n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>-</span>i]<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;1&#39;</span>;
</span></span><span style=display:flex><span>               i<span style=color:#f92672>+=</span>k;
</span></span><span style=display:flex><span>           
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>return</span> s; 
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=further-improvement--reading>Further Improvement / reading</h2><p>text</p></div><div class=post-footer></div></article></main></body></html>