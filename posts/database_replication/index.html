<!doctype html><html lang=en-us><head><title>Database Replication // Vaibhav's Blogs</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.115.4"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Christopher Hart"><meta name=description content><link rel=stylesheet href=/blog/css/main.min.3c3c186cd62e563ad6e2f00a89dbee656ab912d1d46f856b5605dd0232521e2a.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Database Replication"><meta name=twitter:description content="Understanding Database Replication in System Design Introduction Database replication is a technique used to maintain the same data across different databases. The primary goal is to ensure data reliability, redundancy, and availability. In system design, replication is crucial for preventing data loss, load balancing, and improving local data access speed. It is a fundamental concept often discussed during interviews related to system design.
Database Replication Types There are three main types of database replication:"><meta property="og:title" content="Database Replication"><meta property="og:description" content="Understanding Database Replication in System Design Introduction Database replication is a technique used to maintain the same data across different databases. The primary goal is to ensure data reliability, redundancy, and availability. In system design, replication is crucial for preventing data loss, load balancing, and improving local data access speed. It is a fundamental concept often discussed during interviews related to system design.
Database Replication Types There are three main types of database replication:"><meta property="og:type" content="article"><meta property="og:url" content="https://Vaibhav-sarvashreshth.github.io/blog/posts/database_replication/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-18T15:10:44+05:30"><meta property="article:modified_time" content="2023-06-18T15:10:44+05:30"></head><body><header class=app-header><a href=https://Vaibhav-sarvashreshth.github.io/blog/><img class=app-header-avatar src=/blog/avatar.jpg alt="Christopher Hart"></a>
<span class=app-header-title>Vaibhav's Blogs</span><nav class=app-header-menu><a class=app-header-menu-item href=/blog/tags/>Tags</a></nav><p>A blog about all things technical.</p><div class=app-header-social><a href=https://github.com/Vaibhav-sarvashreshth target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://github.com/Vaibhav-sarvashreshth target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Database Replication</h1><div class=post-meta><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Jun 18, 2023</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>7 min read</div></div></header><div class=post-content><h1 id=understanding-database-replication-in-system-design>Understanding Database Replication in System Design</h1><h2 id=introduction>Introduction</h2><p>Database replication is a technique used to maintain the same data across different databases. The primary goal is to ensure data reliability, redundancy, and availability. In system design, replication is crucial for preventing data loss, load balancing, and improving local data access speed. It is a fundamental concept often discussed during interviews related to system design.</p><h2 id=database-replication-types>Database Replication Types</h2><p>There are three main types of database replication:</p><ul><li><strong><a href=#deep-dive-into-master-slave-replication>Master-Slave Replication:</a></strong> One database acts as the &lsquo;master&rsquo;, and the rest act as &lsquo;slaves&rsquo;. The master database performs all the write operations, while the slave databases synchronize with the master database to reflect the changes. This type of replication solves the issue of maintaining data redundancy.</li><li><strong><a href=#master-master-replication>Master-Master Replication:</a></strong> In this type of replication, all databases can handle both read and write operations. Any changes in one database are synchronized across all others. This type of replication is beneficial for load balancing and failover solutions.</li><li><strong><a href=#multi-master-replication>Multi-Master Replication:</a></strong> A step further than the Master-Master Replication, Multi-Master allows multiple databases to accept write operations, and changes are synchronized across all databases. This configuration can handle more substantial traffic but comes with the complexity of conflict resolution.</li></ul><h2 id=deep-dive-into-master-slave-replication>Deep Dive into Master-Slave Replication</h2><p><a href="https://www.karanpratapsingh.com/_next/image?url=%2Fstatic%2Fcourses%2Fsystem-design%2Fchapter-II%2Fdatabase-replication%2Fmaster-slave-replication.png&amp;w=3840&amp;q=75"><img src="https://www.karanpratapsingh.com/_next/image?url=%2Fstatic%2Fcourses%2Fsystem-design%2Fchapter-II%2Fdatabase-replication%2Fmaster-slave-replication.png&amp;w=3840&amp;q=75" alt="Image of Master-Slave Replication"></a></p><p>This is an image of Master-Slave Replication.</p><p>In Master-Slave Replication, the &lsquo;master&rsquo; database takes up all write operations, while &lsquo;slave&rsquo; databases replicate data from the master for reading. This technique helps scale read operations and provides data redundancy, but it has a single point of failure – the master database.</p><p>The steps involved in Master-Slave Replication are:</p><ol><li>Configuring the Master Database: The master database is set up to record changes made to its data.</li><li>Setting Up the Slave Database: The slave database connects to the master to retrieve the master&rsquo;s binary log position and the corresponding database state.</li><li>Replicating Data: The slave database requests the master database for data newer than the slave&rsquo;s current position in the binary log.</li><li>Synchronization: The slave database syncs with the master database at regular intervals, retrieving and executing the operations that the master database has recorded in its binary log.</li></ol><h3 id=advantages>Advantages</h3><ol><li>Backups of the entire database of relatively no impact on the master.</li><li>Applications can read from the slave(s) without impacting the master.</li><li>Slaves can be taken offline and synced back to the master without any downtime.</li></ol><h3 id=disadvantages>Disadvantages</h3><ol><li>Replication adds more hardware and additional complexity.</li><li>Downtime and possibly loss of data when a master fails.</li><li>All writes also have to be made to the master in a master-slave architecture.</li><li>The more read slaves, the more we have to replicate, which will increase replication lag.</li></ol><h2 id=master-master-replication>Master-Master Replication</h2><p><a href="https://www.karanpratapsingh.com/_next/image?url=%2Fstatic%2Fcourses%2Fsystem-design%2Fchapter-II%2Fdatabase-replication%2Fmaster-master-replication.png&amp;w=3840&amp;q=75"><img src="https://www.karanpratapsingh.com/_next/image?url=%2Fstatic%2Fcourses%2Fsystem-design%2Fchapter-II%2Fdatabase-replication%2Fmaster-master-replication.png&amp;w=3840&amp;q=75" alt="Image of Master-Master Replication"></a></p><p>This is an image of Master-Master Replication.</p><p>In Master-Master Replication, two databases serve as masters, where both can handle read and write operations. If one fails, the system can still operate without any data loss. However, it does add a layer of complexity due to potential write conflicts.</p><p>The steps involved in Master-Master Replication are:</p><ol><li>Configuring the Primary Master: The primary master is configured to record changes and synchronize with the secondary master.</li><li>Setting Up the Secondary Master: The secondary master replicates the primary master&rsquo;s data and records its changes.</li><li>Synchronization: Both databases sync with each other at regular intervals, making sure that they have the same data.</li><li>Failover: In case of one master failing, the other can still handle both read and write operations, providing high availability.</li></ol><h3 id=advantages-1>Advantages</h3><ol><li>Applications can read from both masters.</li><li>Distributes write load across both master nodes.</li><li>Simple, automatic, and quick failover.</li></ol><h3 id=disadvantages-1>Disadvantages</h3><ol><li>Not as simple as master-slave to configure and deploy.</li><li>Either loosely consistent or have increased write latency due to synchronization.</li><li>Conflict resolution comes into play as more write nodes are added and as latency increases.</li></ol><h2 id=multi-master-replication>Multi-Master Replication</h2><p><a href=https://user-images.githubusercontent.com/4745789/139211714-fc9266bd-ca22-48c4-9095-c6bff0ae99e6.png><img src=https://user-images.githubusercontent.com/4745789/139211714-fc9266bd-ca22-48c4-9095-c6bff0ae99e6.png alt="Image of Master-Master Replication"></a></p><p>This is an image of Master-Master Replication.</p><p>Multi-Master Replication is an extension of Master-Master Replication where more than two databases can handle write operations. This configuration provides high availability, improved write scalability, and geographical distribution of data.</p><p>However, it does come with its challenges such as managing write conflicts and maintaining data consistency.</p><h3 id=advantages-2>Advantages</h3><ol><li>Enhanced Load Handling Capacity</li></ol><p>Multi-master replication is an effective solution when a database cluster becomes a bottleneck due to increased write traffic. A single node has both theoretical and practical scaling limitations, and it&rsquo;s essential to distribute the load across multiple nodes. In a multi-master setup, multiple master nodes accept incoming write requests, enhancing the capacity to handle increased write requests.</p><ol start=2><li>Data Redundancy</li></ol><p>Creating a consistent, secondary copy of the master database that also accepts write requests is a common use case for multi-master replication. This may sound complex, but such a requirement is common in real-world scenarios. By maintaining a second copy, you ensure data availability even if one master node fails.</p><ol start=3><li>Avoiding Single Point of Failure (SPoF)</li></ol><p>A master node, like any other in a database cluster, is prone to crashes. If a single master node that accepts all write requests crashes, it could lead to significant downtime. Multi-master replication eliminates this single point of failure. If one master node crashes, other master nodes can continue to handle write requests, ensuring uninterrupted operation of the cluster.</p><ol start=4><li>Lower Latencies Across Geographies</li></ol><p>For businesses with clients spread across various geographical locations, write latencies can increase if all writes have to be directed to a single master node. With multi-master replication, you can set up master nodes in different regions, closer to the users. This setup helps minimize write latencies as client requests can be served from the closest master node, enhancing user experience.</p><ol start=5><li>Facilitates Seamless Database Upgrades</li></ol><p>Database upgrades are an inevitable part of system maintenance, but executing these upgrades can be challenging. It&rsquo;s essential to test business logic on a newer version before rolling it out for production use. Multi-master replication allows you to maintain an older version of your database for production while keeping a second updated database for testing. Both databases are kept in sync and can accept write operations. This approach not only facilitates testing but also allows for incremental traffic shifting from the old to the new version, minimizing disruption in case of failure.</p><h3 id=disadvantages-2>Disadvantages</h3><ol><li>Eventual Consistency and Loss of ACID Guarantees</li></ol><p>Multi-master replication operates asynchronously, which means updates made on one master node may take some time to reflect on other master nodes, resulting in eventual consistency. Consequently, a relational database running in multi-master mode loses its ACID (Atomicity, Consistency, Isolation, Durability) guarantees, a potential problem for applications that require immediate consistency.</p><ol start=2><li>Performance Degradation</li></ol><p>In multi-master replication, every update made on one master node needs to be replicated across all other master nodes. This constant data movement can significantly burden network bandwidth, potentially leading to sluggish network performance at scale.</p><ol start=3><li>Conflict Resolution</li></ol><p>A significant challenge of running a database in multi-master mode is dealing with write conflicts. Since all master nodes accept write operations, there may be situations where the same entity is updated on multiple master nodes simultaneously, leading to conflicts during syncing. Resolving these conflicts becomes a crucial aspect of managing a multi-master setup.</p><p>The approach to conflict resolution varies based on specific use cases and business logic. Some applications might discard the entire sequence of conflicting writes, while others might adopt a &ldquo;last write wins&rdquo; strategy. Ultimately, it&rsquo;s the responsibility of the business logic and use case to define the steps to be taken upon a conflict.</p><h2 id=conclusion>Conclusion</h2><p>Database replication is a core part of system design that improves performance, provides redundancy, and ensures high availability. Choosing the right type of replication depends on the specific needs of your system – the volume of read/write operations, data consistency requirements, acceptable latency, etc. However, remember that replication also adds complexity to your system, so a well-thought-out strategy is essential to manage it effectively.</p><p>This tutorial is a high-level overview of Database Replication in System Design. Further reading into each of the replication types and their implementation can provide deeper insights into their advantages, trade-offs, and use cases. Additionally, learning about sharding, partitioning, and other data management techniques can complement your understanding of database replication.</p></div><div class=post-footer></div></article></main></body></html>