<!doctype html><html lang=en-us><head><title>Fast Inverse Square Root - The Genius of a Timeless Algorithm // Vaibhav's Blogs</title>
<link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.121.2"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Vaibhav Mokale"><meta name=description content><link rel=stylesheet href=/blog/css/main.min.3c3c186cd62e563ad6e2f00a89dbee656ab912d1d46f856b5605dd0232521e2a.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Fast Inverse Square Root - The Genius of a Timeless Algorithm"><meta name=twitter:description content="Fast Inverse Square Root: The Genius of a Timeless Algorithm The realm of computer science is replete with remarkable algorithms that often intertwine ingenuity with a touch of mystery. One such algorithm, which originated from the video game industry, offers a rapid method to compute the inverse square root of a floating-point number. Today, let&rsquo;s unravel the beauty behind this fascinating piece of code.
Introduction The Fast Inverse Square Root algorithm, sometimes lovingly referred to as the &ldquo;Quake&rdquo; algorithm due to its association with the game, is a method that uses bit-level operations to quickly approximate the inverse square root of a given float."><meta property="og:title" content="Fast Inverse Square Root - The Genius of a Timeless Algorithm"><meta property="og:description" content="Fast Inverse Square Root: The Genius of a Timeless Algorithm The realm of computer science is replete with remarkable algorithms that often intertwine ingenuity with a touch of mystery. One such algorithm, which originated from the video game industry, offers a rapid method to compute the inverse square root of a floating-point number. Today, let&rsquo;s unravel the beauty behind this fascinating piece of code.
Introduction The Fast Inverse Square Root algorithm, sometimes lovingly referred to as the &ldquo;Quake&rdquo; algorithm due to its association with the game, is a method that uses bit-level operations to quickly approximate the inverse square root of a given float."><meta property="og:type" content="article"><meta property="og:url" content="https://Vaibhav-sarvashreshth.github.io/blog/posts/fast_inverse_square_root/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-12T15:10:44+05:30"><meta property="article:modified_time" content="2023-07-12T15:10:44+05:30"></head><body><header class=app-header><a href=https://Vaibhav-sarvashreshth.github.io/blog/><img class=app-header-avatar src=/blog/avatar.jpg alt="Vaibhav Mokale"></a>
<span class=app-header-title>Vaibhav's Blogs</span><nav class=app-header-menu><a class=app-header-menu-item href=/blog/tags/>Tags</a></nav><p>A blog about all things technical.</p><div class=app-header-social><a href=https://github.com/Vaibhav-sarvashreshth target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://github.com/Vaibhav-sarvashreshth target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Fast Inverse Square Root - The Genius of a Timeless Algorithm</h1><div class=post-meta><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Jul 12, 2023</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>3 min read</div></div></header><div class=post-content><h1 id=fast-inverse-square-root-the-genius-of-a-timeless-algorithm><strong>Fast Inverse Square Root: The Genius of a Timeless Algorithm</strong></h1><p>The realm of computer science is replete with remarkable algorithms that often intertwine ingenuity with a touch of mystery. One such algorithm, which originated from the video game industry, offers a rapid method to compute the inverse square root of a floating-point number. Today, let&rsquo;s unravel the beauty behind this fascinating piece of code.</p><h2 id=introduction><strong>Introduction</strong></h2><p>The Fast Inverse Square Root algorithm, sometimes lovingly referred to as the &ldquo;Quake&rdquo; algorithm due to its association with the game, is a method that uses bit-level operations to quickly approximate the inverse square root of a given float. Here&rsquo;s the code in question:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;math.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>Q_rsqrt</span>( <span style=color:#66d9ef>float</span> number )
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span> <span style=color:#66d9ef>long</span> i;
</span></span><span style=display:flex><span> <span style=color:#66d9ef>float</span> x2, y;
</span></span><span style=display:flex><span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> threehalfs <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.5F</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> x2 <span style=color:#f92672>=</span> number <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5F</span>;
</span></span><span style=display:flex><span> y  <span style=color:#f92672>=</span> number;
</span></span><span style=display:flex><span> i  <span style=color:#f92672>=</span> <span style=color:#f92672>*</span> ( <span style=color:#66d9ef>long</span> <span style=color:#f92672>*</span> ) <span style=color:#f92672>&amp;</span>y;                       
</span></span><span style=display:flex><span> i  <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x5f3759df</span> <span style=color:#f92672>-</span> ( i <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span> );               
</span></span><span style=display:flex><span> y  <span style=color:#f92672>=</span> <span style=color:#f92672>*</span> ( <span style=color:#66d9ef>float</span> <span style=color:#f92672>*</span> ) <span style=color:#f92672>&amp;</span>i;
</span></span><span style=display:flex><span> y  <span style=color:#f92672>=</span> y <span style=color:#f92672>*</span> ( threehalfs <span style=color:#f92672>-</span> ( x2 <span style=color:#f92672>*</span> y <span style=color:#f92672>*</span> y ) );   <span style=color:#75715e>// 1st iteration
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#66d9ef>return</span> y;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float</span> input;
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Give me a random float: &#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%f&#34;</span>, <span style=color:#f92672>&amp;</span>input);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>float</span> output <span style=color:#f92672>=</span> <span style=color:#a6e22e>Q_rsqrt</span>(input);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Output: %f </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, output);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=decoding-the-magic><strong>Decoding the Magic</strong></h2><p>Let&rsquo;s dissect the algorithm step-by-step:</p><ol><li><p>Bit-level Hacking: The line i = * ( long * ) &amp;y; involves type-punning, a method that uses a union or pointer type conversion to break type-safety rules. Here, it&rsquo;s used to obtain the integer representation of the floating-point number.</p></li><li><p>The Magic Number - 0x5f3759df: The enigmatic line i = 0x5f3759df - ( i &#187; 1 ); is at the core of this algorithm. This &ldquo;magic constant&rdquo; comes from empirical testing and is crucial to the algorithm&rsquo;s speed and precision. The operation initializes the approximation by exploiting the properties of IEEE floating-point representation.</p></li><li><p>Newton&rsquo;s Iteration: The line y = y * ( threehalfs - ( x2 * y * y ) ); is a single iteration of Newton&rsquo;s method, a root-finding algorithm. This refines the initial approximation to provide a more accurate result.</p></li></ol><h2 id=origins-and-legacy><strong>Origins and Legacy</strong></h2><p>The algorithm&rsquo;s association with the video game &ldquo;Quake&rdquo; has solidified its place in gaming folklore. John Carmack, the legendary programmer behind many of id Software&rsquo;s hits, is often credited with its popularization, though the exact origins remain shrouded in mystery.</p><p>The beauty of this algorithm lies not just in its speed but in its sheer elegance. In a time when computational resources were scarce, such tricks were instrumental in achieving seemingly impossible feats, like real-time 3D graphics in games.</p><h2 id=closing-thoughts><strong>Closing Thoughts</strong></h2><p>Algorithms like the Fast Inverse Square Root are more than just tools to solve a problem; they embody the essence of computer science — a blend of logic, creativity, and at times, sheer audacity. <strong>It&rsquo;s important to note, however, that while this method is ingenious, it&rsquo;s not necessarily the fastest. Subsequent additions by hardware manufacturers have made this algorithm redundant for the most part. For example, on x86, Intel introduced the SSE instruction <code>rsqrtss</code> in 1999, which offers an even faster approach to this computation</strong>. As we stand at the crossroads of an era dominated by machine learning and artificial intelligence, it&rsquo;s worth remembering and celebrating these iconic snippets that paved the way for the marvels of modern computing, while also acknowledging the relentless pace of technological progress.</p></div><div class=post-footer></div></article></main></body></html>